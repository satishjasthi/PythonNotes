Source: Think python book

*The Python interpreter is a program that reads and executes Python code. Depending on your environment, you might start the interpreter by clicking on an icon, or by typing python on a command line. 

*In python3 print is a function so arguments needs to passed within brackets
Ex: print("Hello world")
However in python2 print is not a function 
Ex: print "hello"

*operators:
/ = division 
** = exponentiation
^ = bitwise operator XOR(exclusively OR ie XOR is true only when one of the variables is true)
x<<y = multiply x by 2**y
x>>y = divide x by 2**y (but the division is python division not the normal one)
~x = returns the complement of x


*Values and types:
Values can be something like 2,33.0,"hello" etc.These values have different types:
2 is integer
33.0 is floating point number
"hello" is a string

To know the type of a value,you can use type() function:
 >>> type(2)
<class 'int'>

type is like a categorical variable which has various categories like int, float, str

*Programming languages are formal languages that have been designed to
express computations.

*SYntax,tokens, parsing,bugs,debugging:
Syntax: Formal languages tend to have strict syntax rules that govern the structure of statements.

tokens:Tokens are the basic elements of the language, such as words, numbers,

parsing: whenever we are reading a formal language we have to identify the strcuture in it, this process is called parsing.

bugs: are the errors in your program

debugging: is the process of identifying those bugs.

Glossary:

problem solving: The process of formulating a problem, finding a solution, and expressing it.

high-level language: A programming language like Python that is designed to be easy for humans to read and write.

low-level language: A programming language that is designed to be easy for a computer to run; also called “machine language” or “assembly language”.

portability: A property of a program that can run on more than one kind of computer.

interpreter: A program that reads another program and executes it

prompt: Characters displayed by the interpreter to indicate that it is ready to take input from the user.

program: A set of instructions that specifies a computation.

print statement: An instruction that causes the Python interpreter to display a value on the screen.

operator: A special symbol that represents a simple computation like addition, multiplication, or string concatenation.

value: One of the basic units of data, like a number or string, that a program manipulates.

type: A category of values. The types we have seen so far are integers (type int), floatingpoint numbers (type float), and strings (type str).

integer: A type that represents whole numbers.

floating-point: A type that represents numbers with fractional parts.

string: A type that represents sequences of characters.

natural language: Any one of the languages that people speak that evolved naturally.

formal language: Any one of the languages that people have designed for specific purposes, such as representing mathematical ideas or computer programs; all programming languages are formal languages.
token: One of the basic elements of the syntactic structure of a program, analogous to a word in a natural language.

syntax: The rules that govern the structure of a program.

parse: To examine a program and analyze the syntactic structure.

bug: An error in a program.

debugging: The process of finding and correcting bug

*Assignment statments:An assignment statement creates a new variable and gives it a value:

>>> message = 'And now for something completely different'
>>> n = 17
>>> pi = 3.141592653589793

*state diagram:A common way to represent variables on paper is to write the name with an arrow pointing to its value. This kind of figure is called a state diagram because it shows what state each
of the variables is in (think of it as the variable’s state of mind).


message ------> 'And now for something completely different'

*Variables: there is no restriction on the length of the variable name it can be anything,but it must begin with alphabets or underscore(_) and not numbers.Furthermore you cannot use keywords as variable names.

Python3's some keywords: 
False, class, finally, is, return,None, continue, for, lambda, try,True, def, from, nonlocal, while,and, del, global, not, with,as, elif, if, or, yield, assert, else, import, pass, break, except, in, raise

Expressions: is a combination of values,variables and operators.A value all by itself is consider expression so as variable.
Ex: 42,m,m+23

Statment:A statement is a unit of code that has an effect, like creating a variable or displaying a value.
Ex: 
>> n = 17
>> print("maria")

.
When you type a statement, the interpreter executes it, which means that it does whatever the statement says. In general, statements don’t have values

Script mode: is what we generaly use to execute large python programs. ie we first write the programe in a text editor and save it with an extension .py, this file is called a script.


Order of operations: Python uses PEMDAS,whenever the operators have same precedence then we have to evaluate from left to right 
Ex: degree / 2 * pi ,here first calculate degree/2 and then multiply by pi

String operator: generally we cannot perform operations on strings except "+" and "*"
+ is used to concatinate
a = "hi";b = "bye"; c = a + b = "hibye"

* is used to repeate
a = 'sammi'*5 = sammisammisammisammisammi

comments: # 


Debugging: there are 3 kinds of errors:
1. Syntax error 2.Runtim error 3.Semantic error


1.Syntax error:“Syntax” refers to the structure of a program and the rules about that structure. For example, parentheses have to come in matching pairs, so (1 + 2) is legal, but 8) is a syntax error.

2.Runtime error: The second type of error is a runtime error, so called because the error does not appear until after the program has started running. These errors are also called exceptions because they usually indicate that something exceptional (and bad) has happened

3.Semantic errors: semantic means meaning, so semantic errors are the errors that cannot be understood by interpreter,it runs the code without error and produces the result, but this result is not what you are expecting from program.often semantic error takes more effort because we humans have identify the error in the program.

Glossary

variable: A name that refers to a value.

assignment: A statement that assigns a value to a variable.

state diagram: A graphical representation of a set of variables and the values they refer to.

keyword: A reserved word that is used to parse a program; you cannot use keywords like if, def, and while as variable names.

operand: One of the values on which an operator operates.

expression: A combination of variables, operators, and values that represents a single result.

evaluate: To simplify an expression by performing the operations in order to yield a single value.

statement: A section of code that represents a command or action. So far, the statements we have seen are assignments and print statements.
execute: To run a statement and do what it says.

interactive mode: A way of using the Python interpreter by typing code at the prompt.

script mode: A way of using the Python interpreter to read code from a script and run it.

script: A program stored in a file.

order of operations: Rules governing the order in which expressions involving multipleoperators and operands are evaluated.

concatenate: To join two operands end-to-end

comment: Information in a program that is meant for other programmers (or anyone reading the source code) and has no effect on the execution of the program.

syntax error: An error in a program that makes it impossible to parse (and therefore impossible to interpret).

exception: An error that is detected while the program is running.

semantics: The meaning of a program.

semantic error: An error in a program that makes it do something other than what the programmer intended

Functions: are like a label to a sequence of statments.while defining functions you'll define these statements and to execute these statements we'll call the function name.

arguments of functions: are the values that are taken by the function

return value: is the value that a function returns

python's in built functions:
*int() : converts given arguments to integers if the arguments are invalid it throws a error
Ex: 
>>int(32)
32

>>int("2")
2

>> int("emma")
ValueError: invalid literal for int() with base 10: 'emma'

int can convert float to int but it won't roundoff float to int
>> int(3.99999999)
3

float(): converts input arguments to float same as int()

>>float(32)
32.0

>> float("6.45")
6.45

>>float("watson")
ValueError: could not convert string to float: 'watson'

module: is a file/repo that contains a collection of related functions.

Math functions: are in python's math module

before using any module we have to call it using import statment
Ex:
import math

once the module is imported we can call its functions by first naming the module name followed by function name seperated by . this format is called dot notation

Ex:
log_of5 = math.log(5)

some of the functions in math module are:
math.log() (log to the base e)
math.log10()
math.sin()
math.pi
math.sqrt()
math.exp()


creating custom functions:

syntax for creating a function:

def function_name(arguments):
	statment1
	statment2

the first line of the function is called header and the rest is called body.

whenever we create a function python actually creates a function object.So the type of function object is function.

Once we have defined a function we can use within other function definition.

Always a function has to be defined before it is recalled

*Flow of execution:
A function call is like a detour in the flow of execution. Instead of going to the next statement, the flow jumps to the body of the function, runs the statements there, and then comes back to pick up where it left off.

*Argumets and parameters:
Arguments are the inputs that we pass to the function Whereas parameters are the variables in which arguments are stored.

All the arguments are evaluated before the function is called,so no matter how many times a function is called arguments are evaluated at he begining ie only once.

Even variables can be passed as arguments, no matter what kind of arguments we pass to the function all these arguments are stored under same name of the parameter we defined in function definition,when a function runs.


Parameters as well as variables used within the function are local,ie they'll be destroyed as soon as the function executes.
If try recall them outside the function you'll get exception error.

Stack diagrams:
To keep track of which variables can be used where, it is sometimes useful to draw a stack diagram. Like state diagrams, stack diagrams show the value of each variable, but they also show the function each variable belongs to.

Each function is represented by a frame. A frame is a box with the name of a function beside it and the parameters and variables of the function inside it. The stack diagram for the a function shown below:

Program: 
def function1(arg1):
	print(arg1)
	return()

def function2(arg2):
	print(arg2)
	function1(arg2)
	return()
arg1 = "hello";
arg2 = "PYTHON"
function1(arg1)
function2(arg2)

stack diagram for the above program:

_main_

arg1----------> "hello"
arg2----------> "PYTHON"

function1

arg1----> "hello"


function2

arg2-----> "PYTHON"

--------------------------------


when you create  a variable outside any function it always belongs to __main__  function

consider
def print_twice(bruce):
	print(bruce)
	print(bruce)
def cat_twice(part1,part2):
	cat = part1 + part2
	print_twice(cat)


Traceback (innermost last):
File "test.py", line 13, in __main__
cat_twice(line1, line2)
File "test.py", line 5, in cat_twice
print_twice(cat)
File "test.py", line 9, in print_twice
print(cat)
NameError: name 'cat' is not defined

This list of functions is called a traceback. It tells you in what program file the error occurred in, and in what line, and what functions were executing at the time. It also shows the line of code that caused the error


FRUITFUL AND VOID FUNCTIONS:
functions which don't return any return value are called void functions.
Let's call function which can returen values as fruitful functions.

if we assign void functions to any variables ,it just stores the None value in that variable because the function doesn't return anything.

Ex:
>>var = print_twice("hello")
hello
hello

>> print var
None


Why functions?
5
• Creating a new function gives you an opportunity to name a group of statements,
which makes your program easier to read and debug.
• Functions can make a program smaller by eliminating repetitive code. Later, if you
make a change, you only have to make it in one place.
• Dividing a long program into functions allows you to debug the parts one at a time
and then assemble them into a working whole.
• Well-designed functions are often useful for many programs. Once you write and debug one, you can reuse it

Debugging :

One of the most important skills you will acquire is debugging. Although it can be frustrating, debugging is one of the most intellectually rich, challenging, and interesting parts of programming.

In some ways debugging is like detective work. You are confronted with clues and you have to infer the processes and events that led to the results you see.

Debugging is also like an experimental science. Once you have an idea about what is going wrong, you modify your program and try again. If your hypothesis was correct, you can predict the result of the modification, and you take a step closer to a working program. If your hypothesis was wrong, you have to come up with a new one. As Sherlock Holmes pointed out, “When you have eliminated the impossible, whatever remains, however improbable, must be the truth.” (A. Conan Doyle, The Sign of Four)

For some people, programming and debugging are the same thing. That is, programming is the process of gradually debugging a program until it does what you want. The idea is that you should start with a working program and make small modifications, debugging them as you go.

For example, Linux is an operating system that contains millions of lines of code, but it started out as a simple program Linus Torvalds used to explore the Intel 80386 chip. According to Larry Greenfield, “One of Linus’s earlier projects was a program that would switch between printing AAAA and BBBB. This later evolved to Linux.” (The Linux Users’
Guide Beta Version 1)

Glossary

function: A named sequence of statements that performs some useful operation. Functions may or may not take arguments and may or may not produce a result.

function definition: A statement that creates a new function, specifying its name, parameters, and the statements it contains.

function object: A value created by a function definition. The name of the function is a variable that refers to a function object.

header: The first line of a function definition.

body: The sequence of statements inside a function definition.
parameter: A name used inside a function to refer to the value passed as an argument.

function call: A statement that runs a function. It consists of the function name followed by an argument list in parentheses.

argument: A value provided to a function when the function is called. This value is assigned to the corresponding parameter in the function.

local variable: A variable defined inside a function. A local variable can only be used inside its function. return value: The result of a function. If a function call is used as an expression, the return value is the value of the expression.

fruitful function: A function that returns a value.

void function: A function that always returns None.

None: A special value returned by void functions.

module: A file that contains a collection of related functions and other definitions.

import statement: A statement that reads a module file and creates a module object.

module object: A value created by an import statement that provides access to the values defined in a module.

dot notation: The syntax for calling a function in another module by specifying the module name followed by a dot (period) and the function name.

composition: Using an expression as part of a larger expression, or a statement as part of a larger statement.
flow of execution: The order statements run in.

stack diagram: A graphical representation of a stack of functions, their variables, and the values they refer to.

frame: A box in a stack diagram that represents a function call. It contains the local variables and parameters of the function.

traceback: A list of the functions that are executing, printed when an exception occurs


*by default print statments enters the new line after execution, in order to avoid it use this syntax

>> print("Hell",end = ' ')
Hell >>

interface design:
* The turtle module:

consider the code
import turtle
bob = turtle.Turtle()
turtle.mainloop()

here we are using turtle module to learn about interface design and functions

import turtle # imports the module which has several functions related to turtle

bob = turtle.Turtle() # calls a functions called Turtle from turtle module and assigns it to bob, ie it creates a turtle object and assigns it to bob.

mainloop tells the window to wait for the user to do something, although in this case there’s not much for the user to do except close the window


Once you create a Turtle, you can call a method to move it around the window. A method is similar to a function, but it uses slightly different syntax. For example, to move the turtle
forward:

bob.forward(100)
The argument of fd is a distance in pixels, so the actual size depends on your display.

Other methods you can call on a Turtle are bk to move backward, lt for left turn, and rt right turn. The argument for lt and rt is an angle in degrees.

Also, each Turtle is holding a pen, which is either down or up; if the pen is down, the Turtle
leaves a trail when it moves. The methods pu and pd stand for “pen up” and “pen down"


Encapsulation:Wrapping a piece of code up in a function is called encapsulation. One of the benefits of encapsulation is that it attaches a name to the code, which serves as a kind of documentation. Another advantage is that if you re-use the code, it is more concise to call a function twice than to copy and paste the body!

Ex:
def square(t):
	for i in range(4):
		t.fd(100)
		t.lt(90)

When a function has more than a few numeric arguments, it is easy to forget what they are, or what order they should be in. In that case it is often a good idea to include the names of the parameters in the argument list:

polygon(bob, n=7, length=70)

These are called keyword arguments because they include the parameter names as “keywords” (not to be confused with Python keywords like while and def)

The interface of a function is a summary of how it is used: what are the parameters? What does the function do? And what is the return value? An interface is “clean” if it allows the caller to do what they want without dealing with unnecessary details.

Ex: 

def circle(t, r):
 circumference = 2 * math.pi * r
 n = 50
 length = circumference / n
 polygon(t, n, length)


In this example, r belongs in the interface because it specifies the circle to be drawn. n is less appropriate because it pertains to the details of how the circle should be rendered.


This process—rearranging a program to improve interfaces and facilitate code re-use—is called refactoring. 


A development plan:

A development plan is a process for writing programs. The process we used in this case study is “encapsulation and generalization”. The steps of this process are:

1. Start by writing a small program with no function definitions.

2. Once you get the program working, identify a coherent piece of it, encapsulate the piece in a function and give it a name.

3. Generalize the function by adding appropriate parameters.

4. Repeat steps 1–3 until you have a set of working functions. Copy and paste working code to avoid retyping (and re-debugging).

5. Look for opportunities to improve the program by refactoring. For example, if you have similar code in several places, consider factoring it into an appropriately general function.

This process has some drawbacks—we will see alternatives later—but it can be useful if you don’t know ahead of time how to divide the program into functions. This approach lets you design as you go along.


docstring:A docstring is a string at the beginning of a function that explains the interface (“doc” is short for “documentation”). 

Ex:
def polyline(t, n, length, angle):

"""Draws n line segments with the given length and angle (in degrees) between them. t is a turtle. """

	for i in range(n):
	.	
	.
	.
By convention all docstrings are triple quotes since they help string to span over multiple lines

 Docstring explains concisely what the function does (without getting into the details of how it does it). It explains what effect each parameter has on the behavior of the function and what type each parameter should be (if it is not obvious). Writing this kind of documentation is an important part of interface design. A  welldesigned interface should be simple to explain; if you have a hard time explaining one of your functions, maybe the interface could be improved



Debugging:

An interface is like a contract between a function and a caller. The caller agrees to provide certain parameters and the function agrees to do certain work.

For example, polyline requires four arguments: t has to be a Turtle; n has to be an integer; length should be a positive number; and angle has to be a number, which is understood to be in degrees.

These requirements are called preconditions because they are supposed to be true before the function starts executing. Conversely, conditions at the end of the function are postconditions. Postconditions include the intended effect of the function (like drawing line segments) and any side effects (like moving the Turtle or making other changes).

Preconditions are the responsibility of the caller. If the caller violates a (properly documented!) precondition and the function doesn’t work correctly, the bug is in the caller, not
the function.

If the preconditions are satisfied and the postconditions are not, the bug is in the function. If your pre- and postconditions are clear, they can help with debugging.


Glossary
method: A function that is associated with an object and called using dot notation.

loop: A part of a program that can run repeatedly.

encapsulation: The process of transforming a sequence of statements into a function definition.

generalization: The process of replacing something unnecessarily specific (like a number) with something appropriately general (like a variable or parameter).

keyword argument: An argument that includes the name of the parameter as a “keyword”.

interface: A description of how to use a function, including the name and descriptions of the arguments and return value.

refactoring: The process of modifying a working program to improve function interfaces and other qualities of the code.

development plan: A process for writing programs

docstring: A string that appears at the top of a function definition to document the function’s interface.

precondition: A requirement that should be satisfied by the caller before a function starts.

postcondition: A requirement that should be satisfied by the function before it ends.


Conditions and recursion:
=========exit=================
*the floor division operator //, divides two numbers and rounds down to an integer.ie it drops the fraction part of a float.

Ex: 
>>150//8
75 
>>150/8
18.75     in python3

>>3//2
1 and not 2

*the modular operator returns the remainder

>>> 5%3
2

The modulus operator is more useful than it seems. For example, you can check whether one number is divisible by another—if x % y is zero, then x is divisible by y.Also, you can extract the right-most digit or digits from a number. For example, x % 10 yields the right-most digit of x (in base 10). Similarly x % 100 yields the last two digits.

True and False are special value that have type bool.

logical operator: and,or,not

Strictly speaking, the operands of the logical operators should be boolean expressions, but Python is not very strict. Any nonzero number is interpreted as True:
>>> 42 and True
True

*Conditional execution:

*if:
syntax:

if expression:
	statement1
	statement2


Occasionally, it is useful to have a body with no statements (usually as a place keeper for code you haven’t written yet). In that case, you can use the pass statement, which does nothing.

if x < 0:
pass # TODO: need to handle negative values!


*if else:

syntax:

if expression :
	statement1
else expression:
	statement2

*Chained conditionals:
Sometimes there are more than two possibilities and we need more than two branches.One way to express a computation like that is a chained conditional.

if x < y:
	print('x is less than y')
elif x > y:
	print('x is greater than y')
else:
	print('x and y are equal')

elif means else if
There is no limit on the number of elif statements. If there is an else clause, it has to be at the end, but there doesn’t have to be one.

*Nested conditionals:

if x == y:
	print('x and y are equal')
else:
	if x < y:
		print('x is less than y')
	else:
		print('x is greater than y')

Although the indentation of the statements makes the structure apparent, nested conditionals become difficult to read very quickly. It is a good idea to avoid them when you
can.

for example if you want to code this expression 0<x<10
then use 

if 0< x <10:
	print("Hello")

*Recursion:

It is legal for one function to call another; it is also legal for a function to call itself. It may not be obvious why that is a good thing, but it turns out to be one of the most magical things a program can do. For example, look at the following function:

def countdown(n):
	if n <= 0:
		print('Blastoff!')
	else:
		print(n)
		countdown(n-1)

A function that calls itself is recursive; the process of executing it is called recursion.


Stack diagrams for recursive functions:

Every time a function gets called, Python creates a frame to contain the function’s local variables and parameters. For a recursive function, there might be more than one frame on the stack at the same time

see image RF1

If a recursion never reaches a base case, it goes on making recursive calls forever, and the program never terminates. This is known as infinite recursion.

Keyboard input:
=============

*input(): function can be used to prompt the user to enter values for program.
in python2 input() takes values in their specific format ie 
strings will be passed within '' or "" and number are passed as usuall

whereas raw_input() takes values in any format and convert them into strings.


"\n" creates a new line ie cursor moves to new line

Debugging:
==========

Debugging
When a syntax or runtime error occurs, the error message contains a lot of information, but it can be overwhelming. The most useful parts are usually:

• What kind of error it was, and
• Where it occurred.

Syntax errors are usually easy to find, but there are a few gotchas. Whitespace errors can be tricky because spaces and tabs are invisible and we are used to ignoring them.

>>> x = 5
>>> y = 6
File "<stdin>", line 1
y = 6
^
IndentationError: unexpected indent

In this example, the problem is that the second line is indented by one space. But the error message points to y , which is misleading. In general, error messages indicate where the problem was discovered, but the actual error might be earlier in the code, sometimes on a previous line. The same is true of runtime errors. Suppose you are trying to compute a signal-to-noise ratio in decibels. The formula is SNR db = 10 log 10 ( P signal /P noise ) . In Python, you might write something like this:

import math
signal_power = 9
noise_power = 10
ratio = signal_power // noise_power
decibels = 10 * math.log10(ratio)
print(decibels)

When you run this program, you get an exception:

Traceback (most recent call last):
File "snr.py", line 5, in ?
decibels = 10 * math.log10(ratio)
ValueError: math domain error

The error message indicates line 5, but there is nothing wrong with that line. To find the real error, it might be useful to print the value of ratio , which turns out to be 0. The problem is in line 4, which uses floor division instead of floating-point division. You should take the time to read error messages carefully, but don’t assume that everything
they say is correct.

Glossary:
=========

floor division: An operator, denoted // , that divides two numbers and rounds down (to-
ward zero) to an integer.
modulus operator: An operator, denoted with a percent sign ( % ), that works on integers
and returns the remainder when one number is divided by another.
boolean expression: An expression whose value is either True or False .
relational operator: One of the operators that compares its operands: == , != , > , < , >= , and
<= .
logical operator: One of the operators that combines boolean expressions: and , or , and
not .
conditional statement: A statement that controls the flow of execution depending on some
condition.
condition: The boolean expression in a conditional statement that determines which
branch runs.
compound statement: A statement that consists of a header and a body. The header ends
with a colon (:). The body is indented relative to the header.
branch: One of the alternative sequences of statements in a conditional statement.
chained conditional: A conditional statement with a series of alternative branches.
nested conditional: A conditional statement that appears in one of the branches of another
conditional statement.
return statement: A statement that causes a function to end immediately and return to the
caller.
recursion: The process of calling the function that is currently executing.
base case: A conditional branch in a recursive function that does not make a recursive call.
infinite recursion: A recursion that doesn’t have a base case, or never reaches it. Eventu-
ally, an infinite recursion causes a runtime error.

================================================================================

FruitFul functions:
===================

*void functions :functions which can modify values,or print some values but cannot return any value are called void functions.For void functions return value is None.

* we can use multiple return statements in a function like this
..........
..........
if exp:
	return value1
if exp2:
	return value2
..........
..........

if any one of the conditns are True the functions exits the function def.Code that appears after a return statement, or any other place the flow of execution can never reach, is called dead code.

abs() is a builtin function to provide absolute function

Incremental development:The goal of incremental development is to avoid long debugging sessions by adding and testing only a small amount of code at a time.

Ex: distance b/w 2 points:

First try:

def distance(x1, y1, x2, y2):
	return 0.0

Second try:

def distance(x1, y1, x2, y2):
	dx = x2 - x1
	dy = y2 - y1
	print('dx is', dx)
	print('dy is', dy)
	return 0.0

Third try:

def distance(x1, y1, x2, y2):
	dx = x2 - x1
	dy = y2 - y1
	dsquared = dx**2 + dy**2
	print('dsquared is: ', dsquared)
	return 0.0

Fourth try:

def distance(x1, y1, x2, y2):
	dx = x2 - x1
	dy = y2 - y1
	dsquared = dx**2 + dy**2
	result = math.sqrt(dsquared)
	return result



The final version of the function doesn’t display anything when it runs; it only returns a value. The print statements we wrote are useful for debugging, but once you get the function working, you should remove them. Code like that is called scaffolding because it is helpful for building the program but is not part of the final product

The key aspects of the Incremental development are:

1. Start with a working program and make small incremental changes. At any point, if there is an error, you should have a good idea where it is.

2. Use variables to hold intermediate values so you can display and check them. 

3. Once the program is working, you might want to remove some of the scaffolding or consolidate multiple statements into compound expressions, but only if it does not make the program difficult to read.

Composition of functions:

Ex: 
def circle_area(xc, yc, xp, yp):
	radius = distance(xc, yc, xp, yp)
	result = area(radius)
	return result
this can be also written as 

def circle_area(xc, yc, xp, yp):
	return area(distance(xc, yc, xp, yp))

In case of Boolean functions:

def is_divisible(x, y):
	if x % y == 0:
		return True
	else:
		return False

this can be written as

def is_divisible(x,y):
	return(x%y == 0)

now these boolean functions can be used for conditions

if is_divisible(x,y):
	print("x is divisible by y")


The power of recursion:
*A recursive definition is similar to a circular definition, in the sense that the definition contains a reference to the thing being
defined.

*If you saw that definition in the dictionary, you might be annoyed. On the other hand, if you looked up the definition of the factorial function, denoted with the symbol !, you might get something like this:

0! = 1
n! = n ( n − 1 ) !

This definition says that the factorial of 0 is 1, and the factorial of any other value, n, is n multiplied by the factorial of n − 1.

Ex:
def factorial(n):
	if n == 0:
		return 1
	else:
		recursive = factorial(n-1)
		result = n * recursive
		return(result)
print(factorial(10))

Leap of faith:
==============
Following the flow of execution is one way to read programs, but it can quickly become overwhelming. An alternative is what I call the “leap of faith”. When you come to a function call, instead of following the flow of execution, you assume that the function works correctly and returns the right result. In fact, you are already practicing this leap of faith when you use built-in functions. When you call math.cos or math.exp , you don’t examine the bodies of those functions. You just assume that they work because the people who wrote the built-in functions were good
programmers. The same is true when you call one of your own functions. For example, in Section 6.4, we wrote a function called is_divisible that determines whether one number is divisible by another. Once we have convinced ourselves that this function is correct—by examining the
code and testing—we can use the function without looking at the body again. The same is true of recursive programs. When you get to the recursive call, instead of following the flow of execution, you should assume that the recursive call works (returns the correct result) and then ask yourself, “Assuming that I can find the factorial of n − 1,
can I compute the factorial of n?” It is clear that you can, by multiplying by n. Of course, it’s a bit strange to assume that the function works correctly when you haven’t finished writing it, but that’s why it’s called a leap of faith!

Ex: for fibanocci series value:

def fibanocci(n):
	if n == 0:
		return(0)
	if n == 1:
		return(1)
	else:
		
		return fibanocci(n-1) + fibanocci(n-2)

print fibanocci(12)

Checking types:
===============
ie the data type of arguments of function matters consider factorial funtion 'factorial', if we pass 0.5 as a input argument then the recursive function becomes infinite recursive function.Because in the first recursive call, the value of n is 0.5. In the next, it is -0.5. From there, it gets smaller (more negative), but it will never be 0.

In such cases We have two choices. We can try to generalize the factorial function to work with floating-point numbers, or we can make factorial check the type of its argument. The first option is called the gamma function and it’s a little beyond the scope of this book. So we’ll go for the second.

we can make use of isinstance(value) to check whether a value is int or float.

Ex: using fibanocci function

def fibanocci(n):
	if  not isinstance(n,int):
		return("Fibanocci is only defined for integers")
	if n<0:
		return("Fibanocci is only defined for +ve numbers")
	if n == 0:
		return(0)
	if n ==1:
		return(1)
	else:
		return(fibanocci(n-1) + fibanocci(n-2))

print fibanocci(12)
		
If we get past both checks, we know that n is positive or zero, so we can prove that the recursion terminates. This program demonstrates a pattern sometimes called a guardian. The first two conditionals act as guardians, protecting the code that follows from values that might cause an error. The guardians make it possible to prove the correctness of the code.

Debugging:
=========

Breaking a large program into smaller functions creates natural checkpoints for debugging. If a function is not working, there are three possibilities to consider:

• There is something wrong with the arguments the function is getting; a precondition
is violated.
• There is something wrong with the function; a postcondition is violated.
• There is something wrong with the return value or the way it is being used.

To rule out the first possibility, you can add a print statement at the beginning of the function and display the values of the parameters (and maybe their types). Or you can write code that checks the preconditions explicitly.

If the parameters look good, add a print statement before each return statement and display the return value. If possible, check the result by hand. Consider calling the function with values that make it easy to check the result (as in Section 6.2).

If the function seems to be working, look at the function call to make sure the return value is being used correctly (or used at all!).
Adding print statements at the beginning and end of a function can help make the flow of execution more visible. For example, here is a version of factorial with print statements:

Ex: run this

def factorial(n):
	space = ' '*(4 * n)
	print(space,'factorial',n)
	if n == 0:
		print(space,'returning1')
		return 1
	else:
		recurse = factorial(n-1)
		result = n * recurse
		print(space,'returning',result)
		return result

print factorial(3)

Glossary:
=========
temporary variable: A variable used to store an intermediate value in a complex calculation.
dead code: Part of a program that can never run, often because it appears after a return statement.
incremental development: A program development plan intended to avoid debugging by adding and testing only a small amount of code at a time.
scaffolding: Code that is used during program development but is not part of the final version.
guardian: A programming pattern that uses a conditional statement to check for and handle circumstances that might cause an error

=======================================================================

Iteration
==========

Reassignment:
============
The way python stores values in memory is different.
when we assign 
X = 5 and then
X = 7

the first time it's value is 5 and second time it is 7 and the state diagram is 

SEE IMAGE RF2

Updating variables:
*increment method: x = x + 1
*decrement method: x = x - 1

while statement:
Syntax:

while exp :
	stat1
	stat2

More formally, here is the flow of execution for a while statement:
1. Determine whether the condition is true or false.
2. If false, exit the while statement and continue execution at the next statement.
3. If the condition is true, run the body and then go back to step 



break statement: helps you to terminate the loop at any desired point.

Ex:
while True:
    line = raw_input('> ')
    if line == 'done':
        break
    print(line)
print('done! :) ')


function to find square roor iteratively:
def square_root(a,x):
	"Gives the square root of a using Newton's method with x as a random value"
	epsilon = 0.0
	while True:
		y = (x + float(a)/x)/2
		print(y,x)
		if abs(x-y) == epsilon:
			break
		x = y
	return(y)
	
print square_root(225,3)	

Algorithms:
===========

To find the product of a single digit number n and 9, replace first digit of product with (n-1) and second digit with (10-n)

Ex: 7 * 9 = 63 here 6 = (7-1) and 3 = (10 - 7)

Similarly, the techniques you learned for addition with carrying, subtraction with borrowing, and long division are all algorithms. One of the characteristics of algorithms is that they do not require any intelligence to carry out. They are mechanical processes where each step follows from the last according to a simple set of rules.

Debugging:

As you start writing bigger programs, you might find yourself spending more time debugging. More code means more chances to make an error and more places for bugs to hide.

One way to cut your debugging time is “debugging by bisection”. For example, if there are 100 lines in your program and you check them one at a time, it would take 100 steps.

Instead, try to break the problem in half. Look at the middle of the program, or near it, for an intermediate value you can check. Add a print statement (or something else that has a verifiable effect) and run the program.

If the mid-point check is incorrect, there must be a problem in the first half of the program. If it is correct, the problem is in the second half.

Every time you perform a check like this, you halve the number of lines you have to search. After six steps (which is fewer than 100), you would be down to one or two lines of code, at least in theory.

In practice it is not always clear what the “middle of the program” is and not always possible to check it. It doesn’t make sense to count lines and find the exact midpoint. Instead, think about places in the program where there might be errors and places where it is easy to put a check. Then choose a spot where you think the chances are about the same that the bug is before or after the check.


The built-in function eval takes a string and evaluates it using the Python inter-
preter. For example:
>>> eval('1 + 2 * 3')
7
>>> import math
>>> eval('math.sqrt(5)')
2.2360679774997898
>>> eval('type(math.pi)')
<class 'float'>
=========================================================================


Strings:
=======
Strings are not like integers, floats, and booleans. A string is a sequence, which means it is an ordered collection of other values.

In python indexing starts from 0

fruit = 'banana'
fruit[1] = a

len(): returns the number of characters of a string

to get the last character of a string use -ve index

fruit[-1] = a

Traversal with for loop:
A lot of computations involve processing a string one character at a time. Often they start at the beginning, select each character in turn, do something to it, and continue until the end. This pattern of processing is called a traversal.

String slices:

A segment of a string is called a slice. Selecting a slice is similar to selecting a character:

>>> s = 'Monty Python'
>>> s[0:5]
'Monty'
>>> s[6:12]
'Python'

The operator [n:m] returns the part of the string from the “n-eth” character to the “m-eth” character, including the first but excluding the last. 

If you omit the first index (before the colon), the slice starts at the beginning of the string. If you omit the second index, the slice goes to the end of the string:

>>> fruit = 'banana'
>>> fruit[:3]
ban
>>> fruit[3:]
ana

If the first index is greater than or equal to the second the result is an empty string, represented by two quotation marks:

>>> fruit = 'banana'
>>> fruit[3:3]
''
>>> fruit[:]
'banana'

Strings are immutable:

>>> greeting = 'Hello, world!'
>>> greeting[0] = 'J'

TypeError: 'str' object does not support item assignment

The “object” in this case is the string and the “item” is the character you tried to assign.For now, an object is the same thing as a value, but we will refine that definition later

The reason for the error is that strings are immutable, which means you can’t change an existing string. The best you can do is create a new string that is a variation on the original:

>>> greeting = 'Hello, world!'
>>> new_greeting = 'J' + greeting[1:]
>>> new_greeting
'Jello, world!'

This example concatenates a new first letter onto a slice of greeting . It has no effect on the original string.

Searching:traversing a sequence and returning when we find what we
are looking for—is called a search

String methods:

Strings provide methods that perform a variety of useful operations. A method is similar to a function—it takes arguments and returns a value—but the syntax is different. For example, the method upper takes a string and returns a new string with all uppercase
letters.

Instead of the function syntax upper(word) , it uses the method syntax word.upper() .
>>> word = 'banana'
>>> new_word = word.upper()
>>> new_word
'BANANA'

This form of dot notation specifies the name of the method, upper , and the name of the string to apply the method to, word . The empty parentheses indicate that this method takes no arguments.

A method call is called an invocation; in this case, we would say that we are invoking upper on word .

string.find('letter/substring')---> gives the index of letter

By default, find starts at the beginning of the string, but it can take a second argument, the index where it should start:
>>> word.find('na', 3)
4

This is an example of an optional argument; find can also take a third argument, the index where it should stop:
>>> name = 'bob'
>>> name.find('b', 1, 2)
-1
This search fails because b does not appear in the index range from 1 to 2 , not including 2 .

The in operator:

The word in is a boolean operator that takes two strings and returns True if the first appears as a substring in the second:

>>> 'a' in 'banana'
True
>>> 'seed' in 'banana'
False

Ex:
def in_both(word1, word2):
	for letter in word1:
		if letter in word2:
			print(letter)

String comparison:

python doesn't considers the upper and lower case strings the same way.

Ex:
word = 'Pineapple'


if word < 'banana':
	print('Your word, ' + word + ', comes before banana.')

Your word, Pineapple, comes before banana.

That is why always convert all strings into lowercase before dealing with strings

Glossary:

object: Something a variable can refer to. For now, you can use “object” and “value”
interchangeably.
sequence: An ordered collection of values where each value is identified by an integer
index.
item: One of the values in a sequence.
index: An integer value used to select an item in a sequence, such as a character in a string.
In Python indices start from 0.
slice: A part of a string specified by a range of indices.
empty string: A string with no characters and length 0, represented by two quotation
marks.
immutable: The property of a sequence whose items cannot be changed.
traverse: To iterate through the items in a sequence, performing a similar operation on
each.
search: A pattern of traversal that stops when it finds what it is looking for.
counter: A variable used to count something, usually initialized to zero and then incre-
mented.
invocation: A statement that calls a method.
optional argument: A function or method argument that is not required.

str.replace('old_value','new_value',number_of_times)
Ex:
name = 'satish'
name.replace('a','ka',2)
skakatish 

replace method just creates a copy of name and outputs the value skakatish but the value of name still remains satish

str.strip('character')
The method strip() returns a copy of the string in which all chars have been stripped from the beginning and the end of the string (default whitespace characters).

syntax:
str.strip([chars])

str = "0000000this is string example....wow!!!0000000";
print str.strip( '0' )

this is string example....wow!!!

The python documentation uses a syntax that might be confusing.
For example, in find(sub[, start[, end]]) , the brackets indicate optional arguments. So sub is required, but start is optional, and if you include start , then end is optional.

fruit = 'banana'
fruit[0:5:2]
'bnn'

>>> fruit[::-1] revers the string banana
'ananab'

str.islower()---> returns True if all letters of string is in lower case

You might want to use the built-in function ord , which converts a character to a numeric code, and chr , which converts numeric codes to characters. Letters of the alphabet are encoded in alphabetical
order, so for example:

>>> ord('m')
109
>>> ord('M')
77

>>> chr(59)
';'
>>> chr(9)
'\t'

===================================================================

Case study: word play
======================

we can open any txt file in python using

data = open('filename') # this creates a file object

The file object provides several methods for reading, including readline , which reads characters from the file until it gets
to a newline and returns the result as a string:

Ex:

>>> fin = open('words.txt')
>>> fin.readline()
'aa\r\n'
>>> fin.readline()
'aah\r\n'
>>> fin.readline()
'aahed\r\n'
>>> fin.readline()
'aahing\r\n'

The file object keeps track of where it is in the file, so if you call readline again, you get the next word

The first word in this particular list is “aa”, which is a kind of lava. The sequence \r\n represents two whitespace characters, a carriage return(a carriage return is a special code that moves the cursor (or print head) to the beginning of the current line. ) and a newline, that separate this
word from the next.

Write a function called is_abecedarian that returns True if the letters in a word appear in alphabetical order (double letters are ok). How many abecedarian words are there?

def is_abecedarian(word):
	previous = word[0]
	for each in word:
		if each < previous:
			return False
		previous = each
	return True

print is_abecedarian("hijk")

using recusrsion:

def abcedarian(word):
	word = word.lower()
	if len(word) == 1:
		return True
	if word[0] > word[1]:
		return False
	return(abcedarian(word[1:]))
print abcedarian('hijk')

using while loop:

def is_abecedarian(word):
	word = word.lower()
	i = 0
	while i < len(word) - 1:
		if word[i + 1] < word[i]:
			return False
		i += 1
	return True

print is_abecedarian('Mnu')


Glossary:

file object: A value that represents an open file.
reduction to a previously solved problem: A way of solving a problem by expressing it
as an instance of a previously solved problem.
special case: A test case that is atypical or non-obvious (and less likely to be handled cor-
rectly).

======================================================================

LISTS:
======

*A list is a sequence:

Like a string, a list is a sequence of values. In a string, the values are characters; in a list,they can be any type. The values in a list are called elements or sometimes items

to create a list enclose the elements within []

nested list = ['string',10,20.0,['lala',78]]
empty list = []

state diagram of for following lists

>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> numbers = [42, 123]
>>> numbers[1] = 5 
>>> empty = []

See IMAGE RF3

Lists are mutable,The syntax for accessing the elements of a list is the same as for accessing the characters of a string—the bracket operator. The expression inside the brackets specifies the index.
Remember that the indices start at 0


the boolean operator in also works on lists:
Ex: l = ['cheese','pizza','garlic']
>>> 'cheese' in l
True

A for loop over an empty list never runs the body:

for x in []:
print('This never happens.')


Eventhough the given list is nested it is still considered as single list.

The + operator concatenates lists:
a = [1, 2, 3]
b = [4, 5, 6]
c = a + b
c
[1,2, 3, 4, 5, 6]
The * operator repeats a list a given number of times:

[0] * 4
[0,0, 0, 0]

[1, 2, 3] * 3
[1,2, 3, 1, 2, 3, 1, 2, 3]


slicing:
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']

>>> t[1:3]
['b', 'c']

>>> t[:4]
['a', 'b', 'c', 'd']

>>> t[3:]
['d', 'e', 'f'


If you omit the first index, the slice starts at the beginning. If you omit the second, the slice goes to the end. So if you omit both, the slice is a copy of the whole list.
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']

list methods:


.append(): adds elements in there raw form

>>> t = ['a', 'b', 'c']
>>> t.append(['d','e'])
>>> t
['a', 'b', 'c', ['d','e']]

.extend(): adds elements individually
>>> t = ['a', 'b', 'c']
>>> t.append(['d','e'])
>>> t
['a', 'b', 'c', 'd','e']

.sort() arranges the elements of list from low to high
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> t
['a', 'b', 'c', 'd', 'e']

Most list methods are void; they modify the list and return None . If you accidentally write t = t.sort() , you will be disappointed with the result.


augmented assignment statement : X += 1

sum(): returns sum of elements of list

>>> t = [1, 2, 3]
>>> sum(t)
6

An operation like this that combines a sequence of elements into a single value is sometimes called reduce.

Deleting elements:
If you know the index of the element you want, you can use pop :

>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> t
['a', 'c']
>>> x
'b'

pop modifies the list and returns the element that was removed. If you don’t provide an index, it deletes and returns the last element.


you can also do it using del

>>>t = ['a','b','c']
>>>del t[2]
>>>t 
['a','b']

If you know the element you want to remove (but not the index), you can use remove :
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> t
['a', 'c']
The return value from remove is None .

To remove more than one element, you can use del with a slice index:
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> t
['a', 'f']

To convert from a string to a list of characters, you can use list :
>>> s = 'spam'
>>> t = list(s)
>>> t
['s', 'p', 'a', 'm']


The list function breaks a string into individual letters. If you want to break a string into
words, you can use the split method:
>>> s = 'pining for the fjords'
>>> t = s.split()
>>> t
['pining', 'for', 'the', 'fjords']

An optional argument called a delimiter specifies which characters to use as word bound-
aries. The following example uses a hyphen as a delimiter:
>>> s = 'spam-spam-spam'
>>> delimiter = '-'
>>> t = s.split(delimiter)
>>> t
['spam', 'spam', 'spam']

join is the inverse of split . It takes a list of strings and concatenates the elements. join is
a string method, so you have to invoke it on the delimiter and pass the list as a parameter:
>>> t = ['pining', 'for', 'the', 'fjords']
>>> delimiter = ' '
>>> s = delimiter.join(t)
>>> s
'pining for the fjords'

In this case the delimiter is a space character, so join puts a space between words. To
concatenate strings without spaces, you can use the empty string, '' , as a delimiter.

Objects and values: 
See image RF4
If we run these assignment statements:

a = 'banana'
b = 'banana'

We know that a and b both refer to a string, but we don’t know whether they refer to the same string. There are two possible states, shown in Figure 10.2.

In one case, a and b refer to two different objects that have the same value. In the second case, they refer to the same object.
To check whether two variables refer to the same object, you can use the is operator.


>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True

In this example, Python only created one string object, and both a and b refer to it. But when you create two lists, you get two objects:
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False

So the state diagram looks like Figure 10.3.

In this case we would say that the two lists are equivalent, because they have the same elements, but not identical, because they are not the same object. If two objects are identical,
they are also equivalent, but if they are equivalent, they are not necessarily identical.

Until now, we have been using “object” and “value” interchangeably, but it is more precise to say that an object has a value. If you evaluate [1, 2, 3] , you get a list object whose value is a sequence of integers. If another list has the same elements, we say it has the same value, but it is not the same object.

Aliasing:

If a refers to an object and you assign b = a , then both variables refer to the same object:
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True

The state diagram looks like Figure 10.4.

See image RF5

The association of a variable with an object is called a reference. In this example, there are two references to the same object.
An object with more than one reference has more than one name, so we say that the object is aliased.

If the aliased object is mutable, changes made with one alias affect the other:

>>> b[0] = 42
>>> a
[42, 2, 3]

Although this behavior can be useful, it is error-prone. In general, it is safer to avoid aliasing when you are working with mutable objects.

For immutable objects like strings, aliasing is not as much of a problem. In this example:
a = 'banana'
b = 'banana'
It almost never makes a difference whether a and b refer to the same string or not.

List arguments:
When you pass a list to a function, the function gets a reference to the list. If the function modifies the list, the caller sees the change. For example, delete_head removes the first element from a list:

def delete_head(t):
del t[0]
Here’s how it is used:
>>> letters = ['a', 'b', 'c']
>>> delete_head(letters)
>>> letters
['b', 'c']

The parameter t and the variable letters are aliases for the same object. The stack diagram looks like Figure 10.5.

Since the list is shared by two frames, I drew it between them.
It is important to distinguish between operations that modify lists and operations that create new lists. For example, the append method modifies a list, but the + operator creates a new list:

>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> t1
[1, 2, 3]
>>> t2
None

append modifies the list and returns None .


t3 = t1 + [4]
t1
2, 3]
t3
[1,2, 3, 4]
t1

The + operator creates a new list and leaves the original list unchanged. This difference is important when you write functions that are supposed to modify lists.

For example, this function does not delete the head of a list:
def bad_delete_head(t):
t = t[1:] # WRONG!

The slice operator creates a new list and the assignment makes t refer to it, but that doesn’t affect the caller.


t4 = [1, 2, 3]
bad_delete_head(t4)
t4
[1,2, 3]

At the beginning of bad_delete_head , t and t4 refer to the same list. At the end, t refers to a new list, but t4 still refers to the original, unmodified list.

An alternative is to write a function that creates and returns a new list. For example, tail returns all but the first element of a list:

def tail(t):
return t[1:]

This function leaves the original list unmodified. Here’s how it is used:
>>> letters = ['a', 'b', 'c']
>>> rest = tail(letters)
>>> rest
['b', 'c']

Debugging:

Careless use of lists (and other mutable objects) can lead to long hours of debugging. Here are some common pitfalls and ways to avoid them:

1. Most list methods modify the argument and return None . This is the opposite of the
string methods, which return a new string and leave the original alone.

If you are used to writing string code like this:

word = word.strip()

It is tempting to write list code like this:

t = t.sort() # WRONG!

Because sort returns None , the next operation you perform with t is likely to fail.Before using list methods and operators, you should read the documentation carefully and then test them in interactive mode.

2. Pick an idiom and stick with it.Part of the problem with lists is that there are too many ways to do things. For example, to remove an element from a list, you can use pop , remove , del , or even a slice assignment.

To add an element, you can use the append method or the + operator. Assuming thatt is a list and x is a list element, these are correct:

t.append(x)
t = t + [x]
t += [x]

And these are wrong:


t.append([x])	#WRONG!
t = t.append(x)	#WRONG!
t + [x]		#WRONG!
t = t + x	#WRONG!

Try out each of these examples in interactive mode to make sure you understand what they do. Notice that only the last one causes a runtime error; the other three are legal, but they do the wrong thing.

3. Make copies to avoid aliasing. If you want to use a method like sort that modifies the argument, but you need to keep the original list as well, you can make a copy.


t = [3, 1, 2]
t2 = t[:]
t2.sort()
t
1, 2]
t2
[1,2, 3]

In this example you could also use the built-in function sorted , which returns a new, sorted list and leaves the original alone.


t2 = sorted(t)
t
[3, 1, 2]
t2
[1, 2, 3]

Glossary:


nested list: A list that is an element of another list.
accumulator: A variable used in a loop to add up or accumulate a result.
augmented assignment: A statement that updates the value of a variable using an opera-
tor like += .
reduce: A processing pattern that traverses a sequence and accumulates the elements into
a single result.
map: A processing pattern that traverses a sequence and performs an operation on each
element.
filter: A processing pattern that traverses a list and selects the elements that satisfy some
criterion.
object: Something a variable can refer to. An object has a type and a value.
equivalent: Having the same value.
identical: Being the same object (which implies equivalence).
reference: The association between a variable and its value.
aliasing: A circumstance where two or more variables refer to the same object.
delimiter: A character or string used to indicate where a string should be split.

random.randint(a,b) returns a random integer N such that a <= N <= b.

import 
i = bisect.bisect_left(word_list,word) # gives the index of word in wordlist from leftmost side

i = bisect.bisect_right(word_list,word) # gives the index of word in wordlist from rightmost side

but in both cases the value of i remains same


string[::n] or List[::n] --> starting from index=0 it prints every item after n places from the old one

>>> word = 'shooled'
>>> word[::2]
'sold'

string[k::n] or List[k::n] is similar to above one except that it starts from k instead of 0.
>>> word[1::2]
'hoe'




=============================================================================================
DICTIONARIES:
=============


A dictionary is a mapping:

A dictionary is like a list, but more general. In a list, the indices have to be integers; in a dictionary they can be (almost) any type.

A dictionary contains a collection of indices, which are called keys, and a collection of
values. Each key is associated with a single value. The association of a key and a value is
called a key-value pair or sometimes an item.

In mathematical language, a dictionary represents a mapping from keys to values, so you
can also say that each key “maps to” a value.

var = dict() or {} #creates a new dictionary

To add items to the dictionary, you can use square brackets:

>>> eng2sp['one'] = 'uno'

This line creates an item that maps from the key 'one' to the value 'uno' .
if you want to create a dictionary with multiple key-value pairs then do like this

m = {'k1':89,'k2':97.....}

Unlike lists the order of key-value pairs in a dictionary is unpredictable.But that’s not a problem because the elements of a dictionary are never indexed with integer indices. Instead, you use the keys to look up the corresponding values:

>>> eng2sp['two']
'dos'

If the key isn’t in the dictionary, you get an exception:
>>> eng2sp['four']
KeyError: 'four'


The len function works on dictionaries; it returns the number of key-value pairs:
>>> len(eng2sp)
3

the in operator works on dictionary also but searches for key 
Ex:
>>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
>>> 'one' in eng2sp
True
>>> 'uno' in eng2sp
False

To check whether a particular value is in dictionary ,do like this
>>vals = eng2sp.values()
>>'uno' in vals
True

The in operator uses different algorithms for lists and dictionaries. For lists, it searches the elements of the list in order, as in Section 8.6. As the list gets longer, the search time gets longer in direct proportion.

For dictionaries, Python uses an algorithm called a hashtable that has a remarkable prop-
erty: the in operator takes about the same amount of time no matter how many items are
in the dictionary. I explain how that’s possible in Section B.4, but the explanation might
not make sense until you’ve read a few more chapters.

Computationally dictionaries are better than lists

Dictionaries have a method called get that takes a key and a default value. If the key
appears in the dictionary, get returns the corresponding value; otherwise it returns the
default value. For example:

>>> h = histogram('a')
>>> h
{'a': 1}
>>> h.get('a', 0) #since a is in h
1
>>> h.get('b', 0) # since b is not in h
0

Looping and dictionaries:

If you use a dictionary in a for statement it traverses the keys of dictionary.

>>> h
{'a': 1, 's': 2, 'b': 1, 'u': 2, 't': 1, 'r': 2, 'o': 2, 'n': 1}
>>> for each in h:
...     print each
... 
a
s
b
u
t
r
o
n


Keys don't occur in a particular order as in lists.to get keys in  a particular order we can use 
>>> for keys in sorted(h):
...     print keys
... 
a
b
n
o
r
s
t
u
>>> 


Reverse lookup:

Given a dictionary d and a key k , it is easy to find the corresponding value v = d[k] . This
operation is called a lookup
	
But what if you have v and you want to find k ? You have two problems: first, there might
be more than one key that maps to the value v . Depending on the application, you might
be able to pick one, or you might have to make a list that contains all of them. Second,
there is no simple syntax to do a reverse lookup; you have to search.
Here is a function that takes a value and returns the first key that maps to that value:

def reverse_lookup(dictionary,value):
	for key in dictionary:
		if dictionary[key] == value:
			return key
	raise LookupError()

The raise statement causes an exception; in this case it causes a LookupError , which is a built-in exception used to indicate that a lookup operation failed.

The raise statement can take a detailed error message as an optional argument. For example:

>>> raise LookupError('value does not appear in the dictionary')
Traceback (most recent call last):
File "<stdin>", line 1, in ?
LookupError: value does not appear in the dictionary.

A reverse lookup is much slower than a forward lookup; if you have to do it often, or if the
dictionary gets big, the performance of your program will suffer.


we can inverese a dictionary by interchanging keys and values as shown below:

def invert_dict(d):
     inverse = dict()
     for key in d:
             val = d[key]
             print "value,key:",val,key
             if val not in inverse:
                     inverse[val] = [key]
                     print 'inverse[val],[key]:',inverse[val],[key]
             else:
                     inverse[val].append(key)
                     print('inverse[val].append(key)',inverse[val].append(key)) 
     return inverse



Lists can be values in a dictionary, as this example shows, but they cannot be keys. Here’s
what happens if you try:
>>> t = [1, 2, 3]
>>> d = dict()
>>> d[t] = 'oops'

Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: list objects are unhashable

I mentioned earlier that a dictionary is implemented using a hashtable and that means that
the keys have to be hashable. 

A hash is a function that takes a value (of any kind) and returns an integer. Dictionaries
use these integers, called hash values, to store and look up key-value pairs.

This system works fine if the keys are immutable. But if the keys are mutable, like lists,
bad things happen. For example, when you create a key-value pair, Python hashes the key
and stores it in the corresponding location. If you modify the key and then hash it again, it
would go to a different location. In that case you might have two entries for the same key,
or you might not be able to find a key. Either way, the dictionary wouldn’t work correctly.


That’s why keys have to be hashable, and why mutable types like lists aren’t. The simplest
way to get around this limitation is to use tuples, which we will see in the next chapter

A previously computed value that is stored for later use is called a memo.
Here is a “memoized” version of fibonacci :

known is a dictionary that keeps track of the Fibonacci numbers we already know. It starts with two items: 0 maps to 0 and 1 maps to 1.

def fibonacci(n):
	if n in known:
		print known
		return known[n]
	res = fibonacci(n-1) + fibonacci(n - 2)
	known[n] = res
	return res


Global Variables:

In the previous code known was defined outside the function so it belongs to a frame called __main__.variables in __main__ are called global varaibles since they can be accessed from any function,unlike local variables which are destroyed at the end of the function.


It is common to use global variables for flags; that is, boolean variables that indicate (“flag”) whether a condition is true. For example, some programs use a flag named verbose to control the level of detail in the output:

verbose = True

def example1():
if verbose:
print('Running example1')

If you try to reassign a global variable, you might be surprised. The following example is supposed to keep track of whether the function has been called:

been_called = False
def example2():
been_called = True # WRONG

But if you run it you will see that the value of been_called doesn’t change. The problem is that example2 creates a new local variable named been_called . The local variable goes
away when the function ends, and has no effect on the global variable.

To reassign a global variable inside a function you have to declare the global variable before you use it:

been_called = False
def example2():
global been_called
been_called = True

The global statement tells the interpreter something like, “In this function, when I say been_called , I mean the global variable; don’t create a local one.” Here’s an example that tries to update a global variable:

count = 0
def example3():
count = count + 1
If you run it you get:

UnboundLocalError: local variable 'count' referenced before assignment

Python assumes that count is local, and under that assumption you are reading it before writing it. The solution, again, is to declare count global.

def example3():
global count
count += 1


If a global variable refers to a mutable value, you can modify the value without declaring the variable:

known = {0:0, 1:1}
def example4():
known[2] = 1

So you can add, remove and replace elements of a global list or dictionary, but if you want to reassign the variable, you have to declare it:

def example5():
global known
known = dict()

Global variables can be useful, but if you have a lot of them, and you modify them frequently, they can make programs hard to debug.

dict.update():
The method update() adds dictionary dict2's key-values pairs in to dict. This function does not return anything.

syntax: dict.update(dict2)

Ex:
dict = {'Name': 'Zara', 'Age': 7}
dict2 = {'Sex': 'female' }

dict.update(dict2)
dict
{'Age': 7, 'Name': 'Zara', 'Sex': 'female'}

The method setdefault() is similar to get(), but will set dict[key]=default if key is not already in dict.

syntax:dict.setdefault(key, default=None)

Ex:dict = {'Name': 'Zara', 'Age': 7}

dict.setdefault('Sex',None)
None

unlike get(),setdefault() adds the key to the exisiting dictionary

we can add multiple values to a single key using the following two methods:

method1:
d1 = {} # create a empty dic
d1.setdefault(key,[]).append(value) #this method allows you to assign multiple values to a key with repeated values.

Ex:
>>> d = {}
>>> d.setdefault('r',[]).append(89)
>>> d
{'r': [89]}
>>> d.setdefault('r',[]).append(56)
>>> d
{'r': [89, 56]}
>>> d.setdefault('r',[]).append(89)
>>> d
{'r': [89, 56, 89]}
>>> 

method2:

d2 = {}
d.setdefault(key,{})[value] = 1 #here the value given for key is an empty dict,so [value] is the value being passed for that empty dict.this method helps you to having duplicate(more than one same value) values for  a key

Ex:

>>> d2 = {}
>>> d2.setdefault('t',{})['one'] = 89
>>> d2
{'t': {'one': 89}}
>>> d2.setdefault('t',{})['two'] = 65
>>> d2
{'t': {'two': 65, 'one': 89}}
>>> d2.setdefault('t',{})['one'] = 65
>>> d2
{'t': {'two': 65, 'one': 65}}
>>> 

in case of dict with a key and multiple values in order to remove any value we can use
d1[key].remove(value)
Ex:
>>> d
{'r': [89, 56, 89]}
>>> d['r'].remove(56)
>>> d
{'r': [89, 89]}
>>> 

to check whether a dict has some key along with some value we can use:

def has_key_with_some_values(d,key):
	return d.has_key(key) and d[key]

In most cases, it is easier to use a function that always returns a list (maybe an empty one), such as:

def get_values_if_any(d, key):
    return d.get(key, [])

Here’s how to remove a key/value pair, leaving emptydictionaries as items of d2 when the last valuefor a key is removed:

del d2[key][value]

you can create a dictionary as follows

d = dict.fromkeys(range(10),None)



Debugging:

As you work with bigger datasets it can become unwieldy to debug by printing and checking the output by hand. Here are some suggestions for debugging large datasets:

Scale down the input: If possible, reduce the size of the dataset. For example if the program reads a text file, start with just the first 10 lines, or with the smallest example you can find. You can either edit the files themselves, or (better) modify the program
so it reads only the first n lines.

If there is an error, you can reduce n to the smallest value that manifests the error, andthen increase it gradually as you find and correct errors.

Check summaries and types: Instead of printing and checking the entire dataset, consider printing summaries of the data: for example, the number of items in a dictionary or the total of a list of numbers.

A common cause of runtime errors is a value that is not the right type. For debugging this kind of error, it is often enough to print the type of a value.

Write self-checks: Sometimes you can write code to check for errors automatically. For example, if you are computing the average of a list of numbers, you could check that the result is not greater than the largest element in the list or less than the smallest.
This is called a “sanity check” because it detects results that are “insane”.

Another kind of check compares the results of two different computations to see if they are consistent. This is called a “consistency check”.

Format the output: Formatting debugging output can make it easier to spot an error. We saw an example in Section 6.9. The pprint module provides a pprint function that displays built-in types in a more human-readable format ( pprint stands for “pretty
print”).

Again, time you spend building scaffolding can reduce the time you spend debugging.

Glossary
mapping: A relationship in which each element of one set corresponds to an element of
another set.
dictionary: A mapping from keys to their corresponding values.
key-value pair: The representation of the mapping from a key to a value.
item: In a dictionary, another name for a key-value pair.
key: An object that appears in a dictionary as the first part of a key-value pair.
value: An object that appears in a dictionary as the second part of a key-value pair. This is
more specific than our previous use of the word “value”.
implementation: A way of performing a computation.
hashtable: The algorithm used to implement Python dictionaries.
hash function: A function used by a hashtable to compute the location for a key.
hashable: A type that has a hash function. Immutable types like integers, floats and strings
are hashable; mutable types like lists and dictionaries are not.
lookup: A dictionary operation that takes a key and finds the corresponding value.
reverse lookup: A dictionary operation that takes a value and finds one or more keys that
map to it.
raise statement: A statement that (deliberately) raises an exception.
singleton: A list (or other sequence) with a single element.
call graph: A diagram that shows every frame created during the execution of a program,
with an arrow from each caller to each callee.
memo: A computed value stored to avoid unnecessary future computation.
global variable: A variable defined outside a function. Global variables can be accessed
from any function.
global statement: A statement that declares a variable name global.
flag: A boolean variable used to indicate whether a condition is true.
declaration: A statement like global that tells the interpreter something about a variable.


======================================================================================

TUPLES:
======
Tuples are immutable:

A tuple is a sequence of values. The values can be any type, and they are indexed by integers, so in that respect tuples are a lot like lists. The important difference is that tuples are immutable.


Syntactically, a tuple is a comma-separated list of values:
>>> t = 'a', 'b', 'c', 'd', 'e'

Although it is not necessary, it is common to enclose tuples in parentheses:
>>> t = ('a', 'b', 'c', 'd', 'e')

To create a tuple with a single element, you have to include a final comma:
>>> t1 = 'a',
>>> type(t1)
<class 'tuple'>

A value in parentheses is not a tuple:
>>> t2 = ('a')
>>> type(t2)
<class 'str'>

Another way to create a tuple is the built-in function tuple . With no argument, it creates
an empty tuple:
>>> t = tuple()
>>> t
()


If the argument is a sequence (string, list or tuple), the result is a tuple with the elements of
the sequence:
>>> t = tuple('lupins')
>>> t
('l', 'u', 'p', 'i', 'n', 's')

Most list operators also work on tuples. The bracket operator indexes an element:
>>> t = ('a', 'b', 'c', 'd', 'e')
>>> t[0]
'a'
And the slice operator selects a range of elements.
>>> t[1:3]
('b', 'c')
But if you try to modify one of the elements of the tuple, you get an error:
>>> t[0] = 'A'
TypeError: object doesn't support item assignment

Because tuples are immutable, you can’t modify the elements. But you can replace one
tuple with another:
>>> t = ('A',) + t[1:]
>>> t
('A', 'b', 'c', 'd', 'e')
This statement makes a new tuple and then makes t refer to it.

The relational operators works with tuples, lists and other sequence types in the same way.Python compares first element of one sequence with the first element of second(which will be the result of comparision),and then moves on to second and so untill they differ.it returns the value of previous comparision result stored just before two elements differ.


Tuple assignment: Often we use following method for swaping 2 variables:
	temp = a
	a = b
	b = temp

but the Tuple assignment is more elegant

a,b = b,a

The left side is a tuple of variables; the right side is a tuple of expressions. Each value is assigned to its respective variable. All the expressions on the right side are evaluated before any of the assignments.


More generally, the right side can be any kind of sequence (string, list or tuple). For example, to split an email address into a user name and a domain, you could write:

>>> addr = 'monty@python.org'
>>> uname, domain = addr.split('@')

The return value from split is a list with two elements; the first element is assigned to uname , the second to domain .
>>> uname
'monty'
>>> domain
'python.org'

Tuples as return values: strictly speaking function can return only one value but using tuples we can return multiple values

The built-in function divmod takes two arguments and returns a tuple of two values, the quotient and remainder. You can store the result as a tuple:


Or use tuple assignment to store the elements separately:
>>> quot, rem = divmod(7, 3)
>>> quot
2
>>> rem
1

Here is an example of a function that returns a tuple:

def min_max(t):
return min(t), max(t)

max and min are built-in functions that find the largest and smallest elements of a sequence.min_max computes both and returns a tuple of two values.

Variable-length argument tuples:

Functions can take a variable number of arguments. A parameter name that begins with * gathers arguments into a tuple. For example, printall takes any number of arguments and prints them:

def printall(*args):
print(args)

The gather parameter can have any name you like, but args is conventional. Here’s how the function works:

>>> printall(1, 2.0, '3')
(1, 2.0, '3')

The complement of gather is scatter. If you have a sequence of values and you want to pass it to a function as multiple arguments, you can use the * operator. For example, divmod takes exactly two arguments; it doesn’t work with a tuple:

>>> t = (7, 3)
>>> divmod(t)
TypeError: divmod expected 2 arguments, got 1

But if you scatter the tuple, it works:
>>> divmod(*t)
(2, 1)

Many of the built-in functions use variable-length argument tuples. For example, max and min can take any number of arguments:
>>> max(1, 2, 3)
3

But sum does not.
>>> sum(1, 2, 3)
TypeError: sum expected at most 2 arguments, got 3


Zip is a built-in function which takes two or more sequences and return a list of tuples.each tuple contain one element from each sequence.

>>> a = (1,5,8)
>>> b = ['alo','gobi','mutter']
>>> zip(a,b)
[(1, 'alo'), (5, 'gobi'), (8, 'mutter')]
>>> zip(b,a)
[('alo', 1), ('gobi', 5), ('mutter', 8)]
>>> 

The result is a zip object that knows how to iterate through the pairs. The most common use of zip is in a for loop:

>>> for pair in zip(b,a):
...     print(pair)
... 
('alo', 1)
('gobi', 5)
('mutter', 8)
>>> 

A zip object is a kind of iterator, which is any object that iterates through a sequence. Iterators are similar to lists in some ways, but unlike lists, you can’t use an index to select an element from an iterator.
If you want to use list operators and methods, you can use a zip object to make a list:

>>> list(zip(s, t))
[('a', 0), ('b', 1), ('c', 2)]

The result is a list of tuples; in this example, each tuple contains a character from the string and the corresponding element from the list.
If the sequences are not the same length, the result has the length of the shorter one.

>>> list(zip('Anne', 'Elk'))
[('A', 'E'), ('n', 'l'), ('n', 'k')]

You can use tuple assignment in a for loop to traverse a list of tuples:
t = [('a', 0), ('b', 1), ('c', 2)]
for letter, number in t:
print(number, letter)

Each time through the loop, Python selects the next tuple in the list and assigns the elements to letter and number . The output of this loop is:
0 a
1 b
2 c

If you combine zip , for and tuple assignment, you get a useful idiom for traversing two (or more) sequences at the same time. For example, has_match takes two sequences, t1 and t2 , and returns True if there is an index i such that t1[i] == t2[i] :

def has_match(t1, t2):
	for x, y in zip(t1, t2):
		if x == y:
		return True
	return False

If you need to traverse the elements of a sequence and their indices, you can use the built-in function enumerate :

for index, element in enumerate('abc'):
print(index, element)

The result from enumerate is an enumerate object, which iterates a sequence of pairs; each pair contains an index (starting from 0) and an element from the given sequence. In this example, the output is
0 a
1 b
2 c

Dictionaries and tuples:

Dictionaries have a method called items that returns a sequence of tuples, where each tuple is a key-value pair.

>>> d = {'a':0, 'b':1, 'c':2}
>>> t = d.items()
>>> t
dict_items([('c', 2), ('a', 0), ('b', 1)])

The result is a dict_items object, which is an iterator that iterates the key-value pairs. You can use it in a for loop like this:

>>> for key, value in d.items():
...
print(key, value)
...
c 2
a 0
b 1

As you should expect from a dictionary, the items are in no particular order.
Going in the other direction, you can use a list of tuples to initialize a new dictionary:

>>> t = [('a', 0), ('c', 2), ('b', 1)]
>>> d = dict(t)
>>> d
{'a': 0, 'c': 2, 'b': 1}

Combining dict with zip yields a concise way to create a dictionary:
>>> d = dict(zip('abc', range(3)))
>>> d
{'a': 0, 'c': 2, 'b': 1}

The dictionary method update also takes a list of tuples and adds them, as key-value pairs, to an existing dictionary.


The dictionary method update also takes a list of tuples and adds them, as key-value pairs, to an existing dictionary.

It is common to use tuples as keys in dictionaries (primarily because you can’t use lists). For example, a telephone directory might map from last-name, first-name pairs to telephone numbers. Assuming that we have defined last , first and number , we could write:

directory[last, first] = number

The expression in brackets is a tuple. We could use tuple assignment to traverse this dictionary.for last, first in directory:

print(first, last, directory[last,first])

This loop traverses the keys in directory , which are tuples. It assigns the elements of each tuple to last and first , then prints the name and corresponding telephone number. There are two ways to represent tuples in a state diagram. The more detailed version shows the indices and elements just as they appear in a list. For example, the tuple ('Cleese', 'John') would appear as in Figure 12.1.
But in a larger diagram you might want to leave out the details. For example, a diagram of the telephone directory might appear as in Figure 12.2.
Here the tuples are shown using Python syntax as a graphical shorthand. The telephone number in the diagram is the complaints line for the BBC, so please don’t call it.

See IMAGE RF6


Sequences of sequences:
I have focused on lists of tuples, but almost all of the examples in this chapter also work with lists of lists, tuples of tuples, and tuples of lists. To avoid enumerating the possible combinations, it is sometimes easier to talk about sequences of sequences.

In many contexts, the different kinds of sequences (strings, lists and tuples) can be used interchangeably. So how should you choose one over the others?
To start with the obvious, strings are more limited than other sequences because the elements have to be characters. They are also immutable. If you need the ability to change the characters in a string (as opposed to creating a new string), you might want to use a list of characters instead.

Lists are more common than tuples, mostly because they are mutable. But there are a few cases where you might prefer tuples:

1. In some contexts, like a return statement, it is syntactically simpler to create a tuple than a list.
2. If you want to use a sequence as a dictionary key, you have to use an immutable type like a tuple or string.
3. If you are passing a sequence as an argument to a function, using tuples reduces the potential for unexpected behavior due to aliasing.

Because tuples are immutable, they don’t provide methods like sort and reverse , which modify existing lists. But Python provides the built-in function sorted , which takes any sequence and returns a new list with the same elements in sorted order, and reversed , which takes a sequence and returns an iterator that traverses the list in reverse order

Glossary:

tuple: An immutable sequence of elements.
tuple assignment: An assignment with a sequence on the right side and a tuple of variables on the left. The right side is evaluated and then its elements are assigned to the variables on the left.
gather: The operation of assembling a variable-length argument tuple.
scatter: The operation of treating a sequence as a list of arguments.
zip object: The result of calling a built-in function zip ; an object that iterates through a
sequence of tuples.
iterator: An object that can iterate through a sequence, but which does not provide list
operators and methods.
data structure: A collection of related values, often organized in lists, dictionaries, tuples,
etc.
shape error: An error caused because a value has the wrong shape; that is, the wrong type
or size.


==========================================================================

Case Study: Data structure selection

Deterministic:
Given the same inputs, most computer programs generate the same outputs every time, so they are said to be deterministic. Determinism is usually a good thing, since we expect
the same calculation to yield the same result. For some applications, though, we want the computer to be unpredictable. Games are an obvious example, but there are more.

Making a program truly nondeterministic turns out to be difficult, but there are ways to make it at least seem nondeterministic. One of them is to use algorithms that generate pseudorandom numbers. Pseudorandom numbers are not truly random because they are generated by a deterministic computation, but just by looking at the numbers it is all but impossible to distinguish them from random.


random function is the one that helps in generating random numbers

random.random() generates floats between 0 and 1 excluding 1

The function randint takes parameters low and high and returns an integer between low and high (including both)
Ex:
>>> random.randint(5, 10)
5
>>> random.randint(5, 10)
9

to choose an element from a sequence at random use 
random.choice(sequence)

Ex:
>>> t = range(10)
>>> random.choice(t)
3
>>> random.choice(t)
9
>>> random.choice(t)
2

The random module also provides functions to generate random values from continuous distributions including Gaussian, exponential, gamma, and a few more.


Sorting basics:

list have a builtin function called list.sort() which only functions on list where as sorted() can be used for to build a new sorted list from an iterable

to arrange a list of numbers in ascending order
>>>sorted([5,2,1,3,4])
[1,2,3,4,5]

You can also use the list.sort() method of a list. It modifies the list in-place (and returns None to avoid confusion). Usually it's less convenient than sorted() - but if you don't need the original list, it's slightly more efficient.

>>> a = [5, 2, 3, 1, 4]
>>> a.sort()
>>> a
[1, 2, 3, 4, 5]

Another difference is that the list.sort() method is only defined for lists. In contrast, the sorted() function accepts any iterable.


>>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
[1, 2, 3, 4, 5]

Key Functions

Starting with Python 2.4, both list.sort() and sorted() added a key parameter to specify a function to be called on each list element prior to making comparisons.

For example, here's a case-insensitive string comparison:


>>> sorted("This is a test string from Andrew".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] # here the words are sorted alphabetically with small letter given more preference

The value of the key parameter should be a function that takes a single argument and returns a key to use for sorting purposes. This technique is fast because the key function is called exactly once for each input record.

A common pattern is to sort complex objects using some of the object's indices as a key. For example:


>>> student_tuples = [
        ('john', 'A', 15),
        ('jane', 'B', 12),
        ('dave', 'B', 10),
]
>>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]


Optional parameters:

It is possible to write programmer-defined functions with optional arguments, too. For example, here is a function that prints the most common words in a histogram 

def print_most_common(hist, num=10):
	t = most_common(hist)
	print('The most common words are:')
	for freq, word in t[:num]:
		print(word, freq, sep='\t')

The first parameter is required; the second is optional. The default value of num is 10.

If you only provide one argument:

print_most_common(hist)

num gets the default value. If you provide two arguments:
print_most_common(hist, 20)

num gets the value of the argument instead. In other words, the optional argument over-rides the default value.

If a function has both required and optional parameters, all the required parameters have to come first, followed by the optional ones.

Dictionary subtraction:
subtract takes dictionaries d1 and d2 and returns a new dictionary that contains all the keys from d1 that are not in d2 . Since we don’t really care about the values, we set them all to None.

def subtract(d1,d2):
	res = dict()
	for key in d1:
		if key not in d2:
			res[Key] = None
	return res

Set:A set object is an unordered collection of distinct hashable objects. Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference.

Like other collections, sets support x in set, len(set), and for x in set. Being an unordered collection, sets do not record element position or order of insertion. Accordingly, sets do not support indexing, slicing, or other sequence-like behavior.


There are currently two built-in set types, set and frozenset. The set type is mutable — the contents can be changed using methods like add() and remove(). Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The frozenset type is immutable and hashable — its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.

Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: {'jack', 'sjoerd'}, in addition to the set constructor.

The constructors for both classes work the same:

class set([iterable])
class frozenset([iterable])
Return a new set or frozenset object whose elements are taken from iterable. The elements of a set must be hashable. To represent sets of sets, the inner sets must be frozenset objects. If iterable is not specified, a new empty set is returned.

Instances of set and frozenset provide the following operations:

len(s)
Return the number of elements in set s (cardinality of s).

x in s
Test x for membership in s.

x not in s
Test x for non-membership in s.

isdisjoint(other)
Return True if the set has no elements in common with other. Sets are disjoint if and only if their intersection is the empty set.

issubset(other)
set <= other
Test whether every element in the set is in other.

set < other
Test whether the set is a proper subset of other, that is, set <= other and set != other.

issuperset(other)
set >= other
Test whether every element in other is in the set.

set > other
Test whether the set is a proper superset of other, that is, set >= other and set != other.

union(*others)
set | other | ...
Return a new set with elements from the set and all others.

intersection(*others)
set & other & ...
Return a new set with elements common to the set and all others.

difference(*others)
set - other - ...
Return a new set with elements in the set that are not in the others.

symmetric_difference(other)
set ^ other
Return a new set with elements in either the set or other but not both.

copy()
Return a new set with a shallow copy of s.

Note, the non-operator versions of union(), intersection(), difference(), and symmetric_difference(), issubset(), and issuperset() methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like set('abc') & 'cbs' in favor of the more readable set('abc').intersection('cbs').

Both set and frozenset support set to set comparisons. Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal).

Instances of set are compared to instances of frozenset based on their members. For example, set('abc') == frozenset('abc') returns True and so does set('abc') in set([frozenset('abc')]).



Markov analysis:
================
A series of random words seldom makes sense because there is no relationship between successive words. For example, in a real sentence you would expect an article like “the” to be followed by an adjective or a noun, and probably not a verb or adverb.

One way to measure these kinds of relationships is Markov analysis, which characterizes, for a given sequence of words, the probability of the words that might come next. For example, the song Eric, the Half a Bee begins:

Half a bee, philosophically,
Must, ipso facto, half not be.
But half the bee has got to be
Vis a vis, its entity. D’you see?

But can a bee be said to be
Or not to be an entire bee
When half the bee is not a bee
Due to some ancient injury?

In this text, the phrase “half the” is always followed by the word “bee”, but the phrase “the bee” might be followed by either “has” or “is”. 

The result of Markov analysis is a mapping from each prefix (like “half the” and “the bee”) to all possible suffixes (like “has” and “is”). 

Given this mapping, you can generate a random text by starting with any prefix and choos-
ing at random from the possible suffixes. Next, you can combine the end of the prefix and the new suffix to form the next prefix, and repeat.

For example, if you start with the prefix “Half a”, then the next word has to be “bee”, because the prefix only appears once in the text. The next prefix is “a bee”, so the next suffix might be “philosophically”, “be” or “due”.

In this example the length of the prefix is always two, but you can do Markov analysis with any prefix length.


in operator is faster for dict than for lists

often you don’t know ahead of time which implementation will be faster. One option is to implement both of them and see which is better. This approach is called benchmarking. A practical alternative is to choose the data structure that is easiest to implement, and then see if it is fast enough for the intended application. If so, there is no need to go on. If not, there are tools, like the profile module, that can identify the places in a program that take
the most time

Next factor is memory which also plays a crucial role in speed,however it is given second priority.

One final thought: in this discussion, I have implied that we should use one data structure for both analysis and generation. But since these are separate phases, it would also be possible to use one structure for analysis and then convert to another structure for generation. This would be a net win if the time saved during generation exceeded the time spent in
conversion.

Debugging
When you are debugging a program, and especially if you are working on a hard bug, there are five things to try:

Reading: Examine your code, read it back to yourself, and check that it says what you meant to say.
Running: Experiment by making changes and running different versions. Often if you display the right thing at the right place in the program, the problem becomes obvious, but sometimes you have to build scaffolding.
Ruminating: Take some time to think! What kind of error is it: syntax, runtime, or semantic? What information can you get from the error messages, or from the output of the program? What kind of error could cause the problem you’re seeing? What did you
change last, before the problem appeared?
Rubberducking: If you explain the problem to someone else, you sometimes find the answer before you finish asking the question. Often you don’t need the other person; you could just talk to a rubber duck. And that’s the origin of the well-known strategy called rubber duck debugging. I am not making this up; see
https://en.wikipedia.org/wiki/Rubber_duck_debugging .
Retreating: At some point, the best thing to do is back off, undoing recent changes, until you get back to a program that works and that you understand. Then you can start rebuilding.


Beginning programmers sometimes get stuck on one of these activities and forget the others. Each activity comes with its own failure mode.
For example, reading your code might help if the problem is a typographical error, but not if the problem is a conceptual misunderstanding. If you don’t understand what your program does, you can read it 100 times and never see the error, because the error is in your head.

Running experiments can help, especially if you run small, simple tests. But if you run experiments without thinking or reading your code, you might fall into a pattern I call “random walk programming”, which is the process of making random changes until the program does the right thing. Needless to say, random walk programming can take a long time. You have to take time to think. Debugging is like an experimental science.

You should have at least one hypothesis about what the problem is. If there are two or more possibilities, try to think of a test that would eliminate one of them.

But even the best debugging techniques will fail if there are too many errors, or if the code you are trying to fix is too big and complicated. Sometimes the best option is to retreat, simplifying the program until you get to something that works and that you understand.

Beginning programmers are often reluctant to retreat because they can’t stand to delete a line of code (even if it’s wrong). If it makes you feel better, copy your program into another file before you start stripping it down. Then you can copy the pieces back one at a time.

Finding a hard bug requires reading, running, ruminating, and sometimes retreating. If you get stuck on one of these activities, try the others.


Glossary
deterministic: Pertaining to a program that does the same thing each time it runs, given the same inputs.
pseudorandom: Pertaining to a sequence of numbers that appears to be random, but is generated by a deterministic program.
default value: The value given to an optional parameter if no argument is provided. override: To replace a default value with an argument.
benchmarking: The process of choosing between data structures by implementing alter-natives and testing them on a sample of the possible inputs.
rubber duck debugging: Debugging by explaining your problem to an inanimate object such as a rubber duck. Articulating the problem can help you solve it, even if the rubber duck doesn’t know Python.

====================================================================

FILES:
======
This chapter introduces the idea of “persistent” programs that keep data in permanent storage, and shows how to use different kinds of permanent storage, like files and databases

Persistence:
Most of the programs that you have ran till now store their results/ouput temproraly in system.if the program is run once again it starts freshly and computes all values once again.There are other kind of programs that are persistent they run for a long time (or all the time); they keep at least some of their data in permanent storage (a hard drive, for example); and if they shut down and restart, they pick up where they left off.

Examples of persistent programs are operating systems, which run pretty much whenever a computer is on, and web servers, which run all the time, waiting for requests to come in on the network.

Reading and writing data:
	we can write data to file that can be stored in a permanent storage like hard drive using open() function in writing mode as follows

fin = open('abc.txt','w')

!!!If the file already exists, opening it in write mode clears out the old data and starts fresh, so be careful! If the file doesn’t exist, a new one is created

open returns a file object that provides methods for working with the file. The write method puts data into the file.

Ex:
>>>fin =  open('abc.txt','w')
>>>line1 = "This here's the wattle,\n"
>>>fin.write(line1)
24 #return number of characters written

The file object keeps track of where it is, so if you call write again, it adds the new data to the end of the file.

When you are done writing, you should close the file.

>>> fin.close()

If you don’t close the file, it gets closed for you when the program ends

The arguments for .write() is always a string,if it is something else we can use formating.

>>> x = 52
>>>fin.write({}.format(x))
'52'

os.getcwd() - return current working dir

os.path.abspath('filename') - returns absolute path of file rather than relative/local path

os.path.exists('filename') - returns True if file in current dir

os.path.isdir('name') - checks whether it's a dir

os.path.isfile('name') - checks whether it's a file

os.listdir(os.curdir) -returns list of files and dir in current dir

Ctrl + l can be used to clean python interpretor

to list all dir and subdir and files within subdir we can use 
os.walk()

for root,files,dirs in os.walk('~'):
	for name in files:
		print(os.path.join(root,name))
	for name in dirs:
		print(os.path.join(root,name))


whenever we feel that by executing certain code the program may throw error we can use try and except statement as a safety

try:	
	fin = open('emma.txt')
except:
	print("I think emma.txt is not in this dir")
Handling an exception with a try statement is called catching an exception.

Databases:
 
A database is a file that is organized for storing data. Many databases are organized like a dictionary in the sense that they map from keys to values. The biggest difference between a database and a dictionary is that the database is on disk (or other permanent storage), so it persists after the program ends.

The module dbm provides an interface for creating and updating database files. As an example, I’ll create a database that contains captions for image files. Opening a database is similar to opening other files:

>>> import dbm
>>> db = dbm.open('captions', 'c')

The mode 'c' means that the database should be created if it doesn’t already exist. The result is a database object that can be used (for most operations) like a dictionary. When you create a new item, dbm updates the database file.

>>> db['cleese.png'] = 'Photo of John Cleese.'

When you access one of the items, dbm reads the file:

>>> db['cleese.png']
b'Photo of John Cleese.'

The result is a bytes object, which is why it begins with b . A bytes object is similar to a string in many ways. When you get farther into Python, the difference becomes important, but for now we can ignore it.

If you make another assignment to an existing key, dbm replaces the old value:

>>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'
>>> db['cleese.png'] 
b'Photo of John Cleese doing a silly walk.'

Some dictionary methods, like keys and items , don’t work with database objects. But iteration with a for loop works:

for key in db:
print(key, db[key])

As with other files, you should close the database when you are done:
>>> db.close()

Pickling:
A limitation of dbm is that the keys and values have to be strings or bytes. If you try to use any other type, you get an error.
The pickle module can help. It translates almost any type of object into a string suitable for storage in a database, and then translates strings back into objects.pickle.dumps takes an object as a parameter and returns a string representation ( dumps is
short for “dump string”):

>>> import pickle
>>> t = [1, 2, 3]
>>> pickle.dumps(t)
b'\x80\x03]q\x00(K\x01K\x02K\x03e.'

The format isn’t obvious to human readers; it is meant to be easy for pickle to interpret.

pickle.loads (“load string”) reconstitutes the object:

>>>t1 = [1,2,3]
>>>s = pickle.dumps(t1)
>>>t2 = pickle.loads(s)
>>>t2
[1,2,3]

Although the new object has the same value as the old, it is not (in general) the same object:

>>> t1 == t2
True
>>> t1 is t2
False

In other words, pickling and then unpickling has the same effect as copying the object. You can use pickle to store non-strings in a database. In fact, this combination is so common that it has been encapsulated in a module called shelve .

Pipes:

Most operating systems provide a command-line interface, also known as a shell. Shells usually provide commands to navigate the file system and launch applications. For example, in Unix you can change directories with cd , display the contents of a directory with ls ,
and launch a web browser by typing (for example) firefox .
Any program that you can launch from the shell can also be launched from Python using a pipe object, which represents a running program.
For example, the Unix command ls -l normally displays the contents of the current directory in long format. You can launch ls with os.popen 1 :

>>> cmd = 'ls -l'
>>> fp = os.popen(cmd)

popen is deprecated now, which means we are supposed to stop using it and start using the subprocess module. But for simple cases, I find subprocess more complicated than necessary. So I am going to keep using popen until they take it away.

The argument is a string that contains a shell command. The return value is an object that behaves like an open file. You can read the output from the ls process one line at a time with readline or get the whole thing at once with read :

>>> res = fp.read()

When you are done, you close the pipe like a file:
>>> stat = fp.close()
>>> print(stat)
None

The return value is the final status of the ls process; None means that it ended normally
(with no errors).

For example, most Unix systems provide a command called md5sum that reads the contents of a file and computes a “checksum”. You can read about MD5 at http://en.wikipedia. org/wiki/Md5 . This command provides an efficient way to check whether two files have the same contents. The probability that different contents yield the same checksum is very small (that is, unlikely to happen before the universe collapses).

You can use a pipe to run md5sum from Python and get the result:

>>> filename = 'book.tex'
>>> cmd = 'md5sum ' + filename
>>> fp = os.popen(cmd)
>>> res = fp.read()
>>> stat = fp.close()
>>> print(res)
1e0033f0ed0656636de0d75144ba32e0 book.tex
>>> print(stat)
None

Writing modules:

Any file that contains Python code can be imported as a module. For example, suppose you have a file named wc.py with the following code:

def linecount(filename):
	count = 0
	for line in open(filename):
		count += 1
	return count

print(linecount('wc.py'))

If you run this program, it reads itself and prints the number of lines in the file, which is 7. You can also import it like this:

>>> import wc
7

Now you have a module object wc :

>>> wc
<module 'wc' from 'wc.py'>

The module object provides linecount :
>>> wc.linecount('wc.py')
7

So that’s how you write modules in Python. The only problem with this example is that when you import the module it runs the test
code at the bottom. Normally when you import a module, it defines new functions but it doesn’t run them.

Programs that will be imported as modules often use the following idiom:

if __name__ == '__main__':
print(linecount('wc.py'))

__name__ is a built-in variable that is set when the program starts. If the program is running as a script, __name__ has the value '__main__' ; in that case, the test code runs. Otherwise,
if the module is being imported, the test code is skipped.

As an exercise, type this example into a file named wc.py and run it as a script. Then run the Python interpreter and import wc . What is the value of __name__ when the module is being imported?

consider a file Demp.py that contains the code:

def linecount(filename):
	count = 0
	with open(filename) as fin:
		for line in fin:
			count += 1
	return count



if __name__ == '__main__':
	print(linecount('Demo.py'))

consider one more file Demo1.py,which contains

import Demo

print(Demo.linecount('englit.txt'))

if __name__ == '__main__':
	print(linecount('Demo.py'))

when you run Demo.py the final if statment executes and you'll get the linecount value
whereas in Demo1.py you'll get an error message as

Traceback (most recent call last):
  File "Demo1.py", line 6, in <module>
    print(linecount('Demo.py'))
NameError: name 'linecount' is not defined

since the function line count is defined in module Demo.py and not in Demo1.py

Warning: If you import a module that has already been imported, Python does nothing. It does not re-read the file, even if it has changed. If you want to reload a module, you can use the built-in function reload , but it can be tricky, so the safest thing to do is restart the interpreter and then import the module again


Debugging:

When you are reading and writing files, you might run into problems with whitespace.These errors can be hard to debug because spaces, tabs and newlines are normally invisible:

>>> s = '1 2\t 3\n 4'
>>> print(s)
1 2 3 
4

The built-in function repr can help. It takes any object as an argument and returns a string representation of the object. For strings, it represents whitespace characters with backslash
sequences:

>>> print(repr(s))
'1 2\t 3\n 4'


One other problem you might run into is that different systems use different characters to indicate the end of a line. Some systems use a newline, represented \n . Others use a return character, represented \r . Some use both. If you move files between different systems, these inconsistencies can cause problems. For most systems, there are applications to convert from one format to another. 
You can find them (and read more about this issue) at http://en.wikipedia.org/wiki/Newline . Or, of course, you could write one yourself


Glossary
persistent: Pertaining to a program that runs indefinitely and keeps at least some of its
data in permanent storage.
format operator: An operator, % , that takes a format string and a tuple and generates a
string that includes the elements of the tuple formatted as specified by the format
string.
format string: A string, used with the format operator, that contains format sequences.
format sequence: A sequence of characters in a format string, like %d , that specifies how a
value should be formatted.
text file: A sequence of characters stored in permanent storage like a hard drive.
directory: A named collection of files, also called a folder.
path: A string that identifies a file.
relative path: A path that starts from the current directory.
absolute path: A path that starts from the topmost directory in the file system.
catch: To prevent an exception from terminating a program using the try and except state-
ments.
database: A file whose contents are organized like a dictionary with keys that correspond
to values.
bytes object: An object similar to a string.
shell: A program that allows users to type commands and then executes them by starting
other programs.
pipe object: An object that represents a running program, allowing a Python program to run commands and read the results.

=========================================================================================

CLASSES AND OBJECTS:
-------------------


Till now we've used all built in types,but now we can create custom made types.
A programmer-defined type is also called a class. A class definition looks like this:

class Point:
	"""Represents a point in 2-D space."""

Defining a class named Point creates a class object.
>>> Point
<class '__main__.Point'>
Because Point is defined at the top level, its “full name” is __main__.Point .

The class object is like a factory for creating objects. To create a Point, you call Point as if it were a function.

>>> blank = Point()
>>> blank
<__main__.Point object at 0xb7e9d3ac>

The return value is a reference to a Point object, which we assign to blank .

Creating a new object is called instantiation, and the object is an instance of the class.
When you print an instance, Python tells you what class it belongs to and where it is stored
in memory (the prefix 0x means that the following number is in hexadecimal).
Every object is an instance of some class, so “object” and “instance” are interchangeable.



Attributes:

You can assign values to an instance using dot notation:

>>> blank.x = 3.0
>>> blank.y = 4.0

This syntax is similar to the syntax for selecting a variable from a module, such as math.pi
or string.whitespace . In this case, though, we are assigning values to named elements of
an object. These elements are called attributes.

As a noun, “AT-trib-ute” is pronounced with emphasis on the first syllable, as opposed to
“a-TRIB-ute”, which is a verb.

The following diagram shows the result of these assignments. A state diagram that shows
an object and its attributes is called an object diagram; see Figure 15.1.

See IMAGE RF7

The variable blank refers to a Point object, which contains two attributes. Each attribute
refers to a floating-point number.

You can read the value of an attribute using the same syntax:

>>> blank.y
4.0
>>> x = blank.x
>>> x
3.0

The expression blank.x means, “Go to the object blank refers to and get the value of x .” In
the example, we assign that value to a variable named x . There is no conflict between the
variable x and the attribute x .


You can use dot notation as part of any expression. For example:

>>> '(%g, %g)' % (blank.x, blank.y)
'(3.0, 4.0)'
>>> distance = math.sqrt(blank.x**2 + blank.y**2)
>>> distance
5.0

You can pass an instance as an argument in the usual way. For example:

def print_point(p):
print('(%g, %g)' % (p.x, p.y))

print_point takes a point as an argument and displays it in mathematical notation. To
invoke it, you can pass blank as an argument:

>>> print_point(blank)
(3.0, 4.0)

Inside the function, p is an alias for blank , so if the function modifies p , blank changes.

Rectangle: Sometimes selecting the attributes of a class may be simple but not always.consider the class rectangle which can these attributes 

There are at least two possibilities:

• You could specify one corner of the rectangle (or the center), the width, and the height.

• You could specify two opposing corners

if we implement a rectangle class with first one as a set of attributes then it looks like this

class Rectangle:
	"""Represents a rectangle.

	attributes: width, height, corner.
	"""
The docstring lists the attributes: width and height are numbers; corner is a Point object that specifies the lower-left corner.

To represent a rectangle, you have to instantiate a Rectangle object and assign values to the attributes:

box = Rectangle()
box.width = 100.0
box.height = 200.0
box.corner = Point()
box.corner.x = 0.0
box.corner.y = 0.0

The expression box.corner.x means, “Go to the object box refers to and select the attribute
named corner ; then go to that object and select the attribute named x .

SEE IMAGE RF8

An object that is an attribute of another object is
embedded.(like corner in rectangle)


Instances as return values:

Functions can return instances. For example, find_center takes a Rectangle as an argument and returns a Point that contains the coordinates of the center of the Rectangle :

def find_center(rect):
p = Point()
p.x = rect.corner.x + rect.width/2
p.y = rect.corner.y + rect.height/2
return p

Here is an example that passes box as an argument and assigns the resulting Point to
center :

>>> center = find_center(box)
>>> print_point(center)
(50, 100)


Objects are mutable:

You can change the state of an object by making an assignment to one of its attributes. For example, to change the size of a rectangle without changing its position, you can modify the values of width and height :

box.width = box.width + 50
box.height = box.height + 100

You can also write functions that modify objects. For example, grow_rectangle takes a
Rectangle object and two numbers, dwidth and dheight , and adds the numbers to the
width and height of the rectangle:
def grow_rectangle(rect, dwidth, dheight):
rect.width += dwidth
rect.height += dheight
Here is an example that demonstrates the effect:
>>> box.width, box.height
(150.0, 300.0)
>>> grow_rectangle(box, 50, 100)
>>> box.width, box.height
(200.0, 400.0)
Inside the function, rect is an alias for box , so when the function modifies rect , box
changes.


Copying: 

Aliasing can make a program difficult to read because changes in one place might have unexpected effects in another place. It is hard to keep track of all the variables that might refer to a given object. Copying an object is often an alternative to aliasing. The copy module contains a function called copy that can duplicate any object:

>>> p1 = Point()
>>> p1.x = 3.0
>>> p1.y = 4.0
>>> import copy
>>> p2 = copy.copy(p1)
p1 and p2 contain the same data, but they are not the same Point.
>>> print_point(p1)
(3, 4)
>>> print_point(p2)
(3, 4)
>>> p1 is p2
False

See IMAGE RF9

>>> p1 == p2
False
 
The is operator indicates that p1 and p2 are not the same object, which is what we ex-
pected. But you might have expected == to yield True because these points contain the
same data. In that case, you will be disappointed to learn that for instances, the default
behavior of the == operator is the same as the is operator; it checks object identity, not
object equivalence. That’s because for programmer-defined types, Python doesn’t know
what should be considered equivalent. At least, not yet

See IMAGE RF9.shows what the object diagram looks like. This operation is called a shallow
copy because it copies the object and any references it contains, but not the embedded
objects

Fortunately, the copy module provides a method named deepcopy that copies not only the
object but also the objects it refers to, and the objects they refer to, and so on. You will not
be surprised to learn that this operation is called a deep copy.

The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):

*A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.

*A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.


Here's a little demonstration:

import copy

a = [1, 2, 3]
b = [4, 5, 6]
c = [a, b]
Using normal assignment operatings to copy:

d = c

print id(c) == id(d)          # True - d is the same object as c
print id(c[0]) == id(d[0])    # True - d[0] is the same object as c[0]
Using a shallow copy:

d = copy.copy(c)

print id(c) == id(d)          # False - d is now a new object
print id(c[0]) == id(d[0])    # True - d[0] is the same object as c[0]
Using a deep copy:

d = copy.deepcopy(c)

print id(c) == id(d)          # False - d is now a new object
print id(c[0]) == id(d[0])    # False - d[0] is now a new object


Debugging:

When you start working with objects, you are likely to encounter some new exceptions. If
you try to access an attribute that doesn’t exist, you get an AttributeError :

>> p = Point()
>>> p.x = 3
>>> p.y = 4
>>> p.z
AttributeError: Point instance has no attribute 'z'
If you are not sure what type an object is, you can ask:
>>> type(p)
<class '__main__.Point'>
You can also use isinstance to check whether an object is an instance of a class:
>>> isinstance(p, Point)
True
If you are not sure whether an object has a particular attribute, you can use the built-in
function hasattr :
>>> hasattr(p, 'x')
True
>>> hasattr(p, 'z')
False
The first argument can be any object; the second argument is a string that contains the name
of the attribute.
You can also use a try statement to see if the object has the attributes you need:
try:
x = p.x
except AttributeError:
x = 0

Glossary
class: A programmer-defined type. A class definition creates a new class object.
class object: An object that contains information about a programmer-defined type. The
class object can be used to create instances of the type.
instance: An object that belongs to a class.
instantiate: To create a new object.
attribute: One of the named values associated with an object.
embedded object: An object that is stored as an attribute of another object.
shallow copy: To copy the contents of an object, including any references to embedded
objects; implemented by the copy function in the copy module.
deep copy: To copy the contents of an object as well as any embedded objects, and any
objects embedded in them, and so on; implemented by the deepcopy function in the
copy module.
object diagram: A diagram that shows objects, their attributes, and the values of the at-
tributes.



=======================================================================

Classes and functions:
======================

In functional programming style there are 2 styles:
1.pure programming: is one which doesn't modify any of the objects passed to it as arguments and it has no effect like displaying a value or getting user input other than returning a value.
2.modifier programming:here we modify the objects that are passed as parameters.and the changes are visible to the caller.




Prototyping versus planning
The development plan I am demonstrating is called “prototype and patch”. For each func-
tion, I wrote a prototype that performed the basic calculation and then tested it, patching
errors along the way.
This approach can be effective, especially if you don’t yet have a deep understanding
of the problem. But incremental corrections can generate code that is unnecessarily
complicated—since it deals with many special cases—and unreliable—since it is hard to
know if you have found all the errors.
An alternative is designed development, in which high-level insight into the problem can
make the programming much easier. In this case, the insight is that a Time object is really
a three-digit number in base 60 (see http://en.wikipedia.org/wiki/Sexagesimal .)! The
second attribute is the “ones column”, the minute attribute is the “sixties column”, and the
hour attribute is the “thirty-six hundreds column”.
When we wrote add_time and increment , we were effectively doing addition in base 60,
which is why we had to carry from one column to the next.
This observation suggests another approach to the whole problem—we can convert Time
objects to integers and take advantage of the fact that the computer knows how to do
integer arithmetic.
Here is a function that converts Times to integers:
def time_to_int(time):
minutes = time.hour * 60 + time.minute
seconds = minutes * 60 + time.second
return seconds
And here is a function that converts an integer to a Time (recall that divmod divides the first
argument by the second and returns the quotient and remainder as a tuple).
def int_to_time(seconds):
time = Time()
minutes, time.second = divmod(seconds, 60)
time.hour, time.minute = divmod(minutes, 60)
return time
You might have to think a bit, and run some tests, to convince yourself that these functions
are correct. One way to test them is to check that time_to_int(int_to_time(x)) == x for
many values of x . This is an example of a consistency check.
Once you are convinced they are correct, you can use them to rewrite add_time :
def add_time(t1, t2):
seconds = time_to_int(t1) + time_to_int(t2)
return int_to_time(seconds)









Debugging
A Time object is well-formed if the values of minute and second are between 0 and 60 (including 0 but not 60) and if hour is positive. hour and minute should be integral values, but we might allow second to have a fraction part.

Requirements like these are called invariants because they should always be true. To put it a different way, if they are not true, something has gone wrong. Writing code to check invariants can help detect errors and find their causes. For example, you might have a function like valid_time that takes a Time object and returns False if it violates an invariant:

def valid_time(time):
	if time.hour < 0 or time.minute < 0 or time.second < 0:
		return False
	if time.minute >= 60 or time.second >= 60:
		return False
	return True

At the beginning of each function you could check the arguments to make sure they are valid:

def add_time(t1, t2):
	if not valid_time(t1) or not valid_time(t2):
		raise ValueError('invalid Time object in add_time')
	seconds = time_to_int(t1) + time_to_int(t2)
	return int_to_time(seconds)

Or you could use an assert statement, which checks a given invariant and raises an exception if it fails:

def add_time(t1, t2):
	assert valid_time(t1) and valid_time(t2)
	seconds = time_to_int(t1) + time_to_int(t2)
	return int_to_time(seconds)

assert statements are useful because they distinguish code that deals with normal conditions from code that checks for errors.

Glossary:

prototype and patch: A development plan that involves writing a rough draft of a pro-
gram, testing, and correcting errors as they are found.
designed development: A development plan that involves high-level insight into the
problem and more planning than incremental development or prototype develop-
ment.
pure function: A function that does not modify any of the objects it receives as arguments.
Most pure functions are fruitful.
modifier: A function that changes one or more of the objects it receives as arguments. Most
modifiers are void; that is, they return None .
functional programming style: A style of program design in which the majority of func-
tions are pure.
invariant: A condition that should always be true during the execution of a program.
assert statement: A statement that check a condition and raises an exception if it fails

We can use datetime() module to deal with the stuff related to dates

import datetime

>>> d = datetime.datetime.now()
>>> d
datetime.datetime(2017, 3, 5, 10, 35, 58, 959059)
>>> 

datetime.datetime(2017, 3, 5, 10, 35, 58, 959059)
>>> p = datetime.datetime.today()
>>> p
datetime.datetime(2017, 3, 5, 10, 36, 38, 591308)
>>> 

>>> d = datetime.datetime.now()
>>> d
datetime.datetime(2017, 3, 5, 10, 37, 14, 82732)
>>> d.day
5
>>> d.month
3
>>> d.year
2017

>>> d = datetime.date(2017,3,5)
>>> d
datetime.date(2017, 3, 5)
>>> 
>>> d.weekday()
6
>>> d.strftime("%A")
'Sunday'
>>> d.strftime("%B")
'March'
>>> d.strftime("%C")
'20'
>>> 

>>> d1 = datetime.date(1995,6,27)
>>> d2 = datetime.date(2017,3,5)
>>> delta = d2 - d1
>>> delta
datetime.timedelta(7922)
>>>delta.days
7922

import calendar

calendar.isleap(year) # is True if year is leap

=====================================================================
Classes and methods:
===================
	
Object-oriented features:

Python is an object-oriented programming language, which means that it provides features that support object-oriented programming, which has these defining characteristics:

• Programs include class and method definitions.
• Most of the computation is expressed in terms of operations on objects.
• Objects often represent things in the real world, and methods often correspond to the ways things in the real world interact.

a method is a function that is associated with a particular class

Methods are semantically the same as functions, but there are two syntactic differences:

• Methods are defined inside a class definition in order to make the relationship between the class and the method explicit.
• The syntax for invoking a method is different from the syntax for calling a function.

Printing objects: 

In Chapter 16, we defined a class named Time and in Section 16.1, you wrote a function named print_time :

class Time:
"""Represents the time of day."""
def print_time(time):
print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))

To call this function, you have to pass a Time object as an argument:

>>> start = Time()
>>> start.hour = 9
>>> start.minute = 45
>>> start.second = 00
>>> print_time(start)
09:45:00

To make print_time a method, all we have to do is move the function definition inside the class definition. Notice the change in indentation.

class Time:
def print_time(time):
print('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))

Now there are two ways to call print_time . The first (and less common) way is to use function syntax:

>>> Time.print_time(start)
09:45:00

In this use of dot notation, Time is the name of the class, and print_time is the name of themethod. start is passed as a parameter.
The second (and more concise) way is to use method syntax:
>>> start.print_time()
09:45:00

In this use of dot notation, print_time is the name of the method (again), and start is the object the method is invoked on, which is called the subject. Just as the subject of a sentence is what the sentence is about, the subject of a method invocation is what the
method is about.

Inside the method, the subject is assigned to the first parameter, so in this case start is assigned to time .By convention, the first parameter of a method is called self , so it would be more common
to write print_time like this:

class Time:
def print_time(self):
print('%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second))

The reason for this convention is an implicit metaphor:
• The syntax for a function call, print_time(start) , suggests that the function is the
active agent. It says something like, “Hey print_time ! Here’s an object for you to
print.”
• In object-oriented programming, the objects are the active agents. A method invocation like start.print_time() says “Hey start ! Please print yourself.”

This change in perspective might be more polite, but it is not obvious that it is useful. In the examples we have seen so far, it may not be. But sometimes shifting responsibility from the
functions onto the objects makes it possible to write more versatile functions (or methods), and makes it easier to maintain and reuse code.


Here’s a version of increment (from Section 16.3) rewritten as a method:

# inside class Time:

def increment(self, seconds):
	seconds += self.time_to_int()
	return int_to_time(seconds)

This version assumes that time_to_int is written as a method. Also, note that it is a pure function, not a modifier.Here’s how you would invoke increment :

>>> start.print_time()
09:45:00
>>> end = start.increment(1337)
>>> end.print_time()
10:07:17

The subject, start , gets assigned to the first parameter, self . The argument, 1337 , gets assigned to the second parameter, seconds .

This mechanism can be confusing, especially if you make an error. For example, if you invoke increment with two arguments, you get:

>>> end = start.increment(1337, 460)
TypeError: increment() takes 2 positional arguments but 3 were given

The error message is initially confusing, because there are only two arguments in parentheses. But the subject is also considered an argument, so all together that’s three.

By the way, a positional argument is an argument that doesn’t have a parameter name; that is, it is not a keyword argument. In this function call:sketch(parrot, cage, dead=True)parrot and cage are positional, and dead is a keyword argument

A more complicated example:

Rewriting is_after (from Section 16.1) is slightly more complicated because it takes two Time objects as parameters. In this case it is conventional to name the first parameter self and the second parameter other :

# inside class Time:

def is_after(self, other):
	return self.time_to_int() > other.time_to_int()

To use this method, you have to invoke it on one object and pass the other as an argument:

>>> end.is_after(start)
True

The init method:

The init method (short for “initialization”) is a special method that gets invoked when an object is instantiated. Its full name is __init__ (two underscore characters, followed by init , and then two more underscores). An init method for the Time class might look like this:

# inside class Time:
def __init__(self, hour=0, minute=0, second=0):
	self.hour = hour
	self.minute = minute
	self.second = second

It is common for the parameters of __init__ to have the same names as the attributes. The statement

	self.hour = hour


stores the value of the parameter hour as an attribute of self .
The parameters are optional, so if you call Time with no arguments, you get the default values.

>>> time = Time()
>>> time.print_time()
00:00:00

If you provide one argument, it overrides hour :
>>> time = Time (9)
>>> time.print_time()
09:00:00

If you provide two arguments, they override hour and minute .
>>> time = Time(9, 45)
>>> time.print_time()
09:45:00

And if you provide three arguments, they override all three default values.

The __str__ method:

__str__ is a special method, like __init__ , that is supposed to return a string representation of an object.

For example, here is a str method for Time objects:

# inside class Time:

def __str__(self):
	return '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)

When you print an object, Python invokes the str method:
>>> time = Time(9, 45)
>>> print(time)
09:45:00

When I write a new class, I almost always start by writing __init__ , which makes it easier to instantiate objects, and __str__ , which is useful for debugging.As an exercise, write a str method for the Point class. Create a Point object and print it.

Operator overloading:

By defining other special methods, you can specify the behavior of operators on programmer-defined types. For example, if you define a method named __add__ for the Time class, you can use the + operator on Time objects. Here is what the definition might look like:

# inside class Time:

def __add__(self, other):
	seconds = self.time_to_int() + other.time_to_int()
	return int_to_time(seconds)

And here is how you could use it:

>>> start = Time(9, 45)
>>> duration = Time(1, 35)
>>> print(start + duration)
11:20:00

When you apply the + operator to Time objects, Python invokes __add__ . When you print the result, Python invokes __str__ . So there is a lot happening behind the scenes!

Changing the behavior of an operator so that it works with programmer-defined types is called operator overloading. For every operator in Python there is a corresponding spe-
cial method, like __add__ .






































====================================================================
Source:Udacity
Course: Programming foundations with python

Whenever you are calling a function from a module file say webrowser.open(),we are just calling the function open() from webbrowser module,Whereas in case of a class and method, when we call say turtle.Turtle(), we are calling Turtle() method from turtle class,in this case the computer runs the __init__ method within turtle class and creates space for the turtle object within memory

See image RF10










