* Algorithm” is just a fancy word for a procedure or recipe—a detailed description of how to do something.

*Ordinary integers can’t be larger than 2147483647 (or smaller than –2147483648); if you want really big numbers, you have to use longs. A long (or long integer) is written just like an ordinary integer but with an L at the end. (You can, in theory, use a lowercase l as well, but that
looks all too much like the digit 1, so I’d advise against it.)

*. Variable names can consist of letters, digits, and underscore characters (_). A variable can’t begin
with a digit, so Plan9 is a valid variable name, whereas 9Plan is not.

*.So, what’s the difference between a statement and an expression? Well, an
expression is something, while a statement does something

*input() function is used to accept values from user

*.Values aren’t stored in variables—they’re stored in some murky depths of computer memory, and are referred to by variables. As will become abundantly clear as you read on, more than one variable can refer to the same value.

pow(a,b) gives a^b
abs(a) gives absolute value of a
round(a/b) round offs fraction a/b to the nearest integer

*.You may think of modules as extensions that can be imported into Python to extend its capabilities. You import modules with a special command called (naturally enough) import. The function we needed in the previous section (floor) is in a module called math:
import math # here math is a module

Notice how this works: We import a module with import, and then use the functions from
that module by writing module.function

Modules. Modules are extensions that can be imported into Python to extend its capabilities. For example, several useful mathematical functions are available in the math module.

*. int(a) convert a into integer type

*.ceil : finds the smallest integral value larger than or equal to the given
number.

*.You may, in fact, use variables to refer to functions (and most other things in Python). For example, by
performing the assignment foo = math.sqrt you can start using foo to calculate square roots; for example,
foo(4) yields 2.

*. module __future__ from which we can
import features that will be standard in Python in the future but that aren’t part of the language
yet

*.Sometimes you want to execute a Python program (also called a script) the same way you execute other programs (such as your Web browser, or your text editor), rather than explicitly using the Python interpreter. In UNIX, there is a standard way of doing this: have the first line
of your script begin with the character sequence #! (called pound bang or shebang) followed by the absolute path to the program that interprets the script (in our case Python). Even if you
didn’t quite understand that, just put the following in the first line of your script if you want it to run easily on UNIX:
#!/usr/bin/env python
This should run the script, regardless of where the Python binary is located.

In some systems if you install a recent version of Python (e.g., 2.4) you will still have an old one lying
around (e.g.,1.5.2), which is needed by some system programs (so you can’t uninstall it). In such cases, the
/usr/bin/env trick is not a good idea, as you will probably end up with your programs being executed by
the old Python. Instead, you should find the exact location of your new Python executable (probably called
python or python2) and use the full path in the pound bang line, like this:
#/usr/bin/python2
The exact path may vary from system to system.

# for comments

backslash character (\) to print special characters
Ex: 'Let\'s go!' however it is not neede if we use "Let's go!"


*.Concatenating Strings:
>>> x = "Hello, "
>>> y = "world!"
>>> x + y
'Hello, world!'

*.str, repr, and backticks are three ways of converting a Python value to a string.
The function str makes it look good, while repr (and the backticks) tries to make the resulting
string a legal Python expression.

Ex: num = 256
"HelloWorld" + num : doesn't work, however
"HelloWorld" + `num` : works because I have converted num into string using ``

*.input() vs raw_input():
input takes in the values in a specific format 
Ex: strings with in "" or ''
numbers as it is
ie while passing the values they need to be in their respective datatype syntax.

raw_input: takes any value in any format and converts them into strings

*.These alternate string syntaxes can be useful when you have strings that span several lines, or that contain various special characters.

1. """ """ / ''' ''' can be used for strings which span over multiple lines

2.raw strings:
As you can see, raw strings are written with an r in front. It would seem that you can put almost
anything inside a raw string, and that is almost true

ex: without r 
path = 'C:\\Program Files\\fnord\\foo\\bar\\baz\\frozz\\bozz'

with r
 print r'C:\Program Files\fnord\foo\bar\baz\frozz\bozz'

*.The one thing you can’t have in a raw string is a final backslash. In other words, the last
character in a raw string cannot be a backslash. Given the previous example, that ought to be
obvious. If the last character (before the final quote) is a backslash, Python won’t know whether
to end the string or not:
>>> print r"This is illegal\"
SyntaxError: invalid token


*.Okay, so it’s reasonable, but what if you want the last character in your raw string to be a
backslash? (Perhaps it’s the end of a DOS path, for example.) Well, I’ve given you a whole bag
of tricks in this section that should help you solve that problem, but basically you need to put
the backslash in a separate string. A simple way of doing that is the following:
>>> print r'C:\Program Files\foo\bar' '\\'
C:\Program Files\foo\bar\
Note that you can use both single and double quotes with raw strings. Even triple-quoted
strings can be raw.

*Unicode strings:
>>> u'Hello, world!'
u'Hello, world!'
As you can see, Unicode strings use the prefix u, just as raw strings use the prefix r.

Functions learnt till now:
abs(number) Returns the absolute value of a number
cmath.sqrt(number) Square root, also for negative numbers
float(object) Converts a string or number to a floating-point number
help() Offers interactive help
input(prompt) Gets input from the user
int(object) Converts a string or number to an integer
long(object) Converts a string or number to a long integer
math.ceil(number) Returns the ceiling of a number as a float
math.floor(number) Returns the floor of a number as a float
math.sqrt(number) Square root, not for negative numbers
pow(x, y[, z]) x to the power of y (modulo z)
raw_input(prompt) Gets input from the user, as a string
repr(object) Returns a string-representation of a value
round(number[, ndigits]) Rounds a number to a given precision
str(object) Converts a value to a string

****************************************
*.LISTS AND TUPLES

*.data structures: A data structure is a collection of data elements (such as numbers or characters—or even other data structures) that is structured in some way, for example, by numbering the elements. The most basic data structure in Python is
the sequence. Each element of a sequence is assigned a number—its position, or index. The first index is zero, the second index is one, and so forth.


 When you count or number things in your daily life, you probably start counting from 1. The numbering
scheme used in Python may seem odd, but it is actually quite natural. One of the reasons for this, as you see
later in the chapter, is that you can also count from the end: The last item of a sequence is numbered –1, the
next-to-last –2, and so forth. That means you can count forward or backward from the first element, which
lies at the beginning, or zero. Trust me, you get used to it.

*.Python has six built-in types of sequences,

*.Among them most famous are lists and tuples.The main difference between these is that you can change a list, but you can’t change a tuple.

The other built-in sequence types are strings, Unicode strings,
buffer objects, and xrange objects

*.lists:
the items of a list are separated by commas and enclosed in
square brackets

*.Python has a basic notion of a kind of data structure called a container, which is basically any object
that can contain other objects. The two main kinds of containers are sequences (such as lists and tuples) and
mappings (such as dictionaries). While the elements of a sequence are numbered, each element in a mapping
has a name (also called a key).

*.Indexing
All elements in a sequence are numbered—from zero and upwards. You can access them
individually with a number, like this:
>>> greeting = 'Hello'
>>> greeting[0]
'H'
A string is just a sequence of characters. The index 0 refers to the first element, in this case the letter H.

 When you use a negative index, Python counts from the right, that is, from the last
element. The last element is at position –1 (not –0, as that would be the same as the first element):
>>> greeting[-1]
'g'

String literals (and other sequence literals, for that matter) may be indexed directly, without
using a variable to refer to them. The effect is exactly the same:
>>> 'Hello'[1]
'e'

If a function call returns a sequence, you can index it directly. For instance, if you are simply
interested in the fourth digit in a year entered by the user, you could do something like this:
>>> fourth = raw_input('Year: ')[3]
Year: 2005
>>> fourth
'5'

*.Slicing:
tag = ["<a href="http://www.python.org">Python web site</a>"]

tag[9:30]
'http://www.python.org'

*.In tag[9:30], you supply two indices as limits for your slice, where the first is inclusive, and the
second is exclusive

*.Consider
 numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbers[-3:-1]
[8, 9] it returns 2 elements(-3-(-1) = -2)

*.to get last three
numbers[-3:]
[8, 9, 10]

*.to get first three
numbers[:3]

*.if you want all elements 
numbers[:]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


*.When slicing, you specify (either explicitly or implicitly) the start and end points of the slice.
Another parameter (added to the built-in types in Python 2.3), which normally is left implicit,
is the step length. In a regular slice, the step length is one—the slice “moves” from one element
to the next, returning all the elements between the start and end:
>>> numbers[0:10:1]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

>>> numbers[0:10:2] #this is simply gives first_number & add 2 previous numbers
[1, 3, 5, 7, 9]
>>> numbers[3:6:3] # take the third number which is 4 here and add 3
[4]


*.If you can still use the shortcuts mentioned earlier; if you want every fourth element of a
sequence, you only have to supply a step size of four:

>>> numbers[::4]
[1, 5, 9]


*.Naturally, the step size can’t be zero—that wouldn’t get you anywhere—but it can be
negative, which means extracting the elements from right to left:

>>> numbers[8:3:-1] give the ordering in reverse order ie 8 to 3 here
[9, 8, 7, 6, 5]
>>> numbers[10:0:-2]
[10, 8, 6, 4, 2]
>>> numbers[0:10:-2]
[]
>>> numbers[::-2]
[10, 8, 6, 4, 2]
>>> numbers[5::-2] #start from position 5 and extract all values below it
[6, 4, 2]
>>> numbers[:5:-2] #start from end till position 3 with increments -2
[10, 8]

*.Adding Sequences

*.Sequences can be concatenated with the addition (plus) operator:

>>> [1, 2, 3] + [4, 5, 6]
[1, 2, 3, 4, 5, 6]

>>> 'Hello, ' + 'world!'
'Hello, world!'

>>> [1, 2, 3] + 'world!'
Traceback (innermost last):
File "<pyshell#2>", line 1, in ?

[1, 2, 3] + 'world!'
TypeError: can only concatenate list (not "string") to list

*.As you can see from the error message, you can’t concatenate a list and a string, although
both are sequences. In general, you can only concatenate two sequences of the same kind


*.Multiplication

*.Multiplying a sequence by a number x creates a new sequence where the original sequence is
repeated x times:

>>> 'python' * 5
'pythonpythonpythonpythonpython'

>>> [42] * 10
[42, 42, 42, 42, 42, 42, 42, 42, 42, 42]



*.None, Empty Lists, and Initialization:

*.Sometimes, however, you would like a value that somehow means “nothing,” as in “we haven’t put
anything here yet.” That’s when you use None. None is a Python value and means exactly that—
“nothing here.” So if you want to initialize a list of length 10, you could do the following:

>>> sequence = [None] * 10
>>> sequence
[None, None, None, None, None, None, None, None, None, None]

*.Membership: To check whether a value is in a list or not we can use 'in'

suppose c = [1,2,3,45,6,8,9,8]

>>> 45 in c ;returns TRUE
>>> 49 in c returns FALSE


*.The last example is a bit different from the others. In general, the in operator checks whether an
object is a member (that is, an element) of a sequence (or some other collection).


*.Length, Minimum, and Maximum
The built-in functions len, min, and max can be quite useful. The function len returns the
number of elements a sequence contains, while min and max return the smallest and largest
element of the sequence respectively

>>> numbers = [100, 34, 678]
>>> len(numbers)
3


*.max and min are not called with a sequence argument; the numbers are supplied
directly as arguments

>>> max(numbers)
678
>>> min(numbers)
34
>>> max(2, 3)
3
>>> min(9, 3, 2, 5)
2

*.The list Function
Because strings can’t be modified in the same way as lists, often it can be useful to create a list
from a string. You can do this with the list function:1
>>> list('Hello')
['H', 'e', 'l', 'l', 'o']
Note that list works with all kinds of sequences, not just strings

*. To convert a list of characters such as the preceding code back to a string, you would use the following
expression:
''.join(somelist)
where somelist is your list

*.BASIC LIST OPERATIONS:
*.Changing Lists: Item Assignments

Changing a list is easy. You just use ordinary assignment
>>> x = [1, 1, 1]
>>> x[1] = 2
>>> x
[1, 2, 1]


*.Deleting Elements:

Deleting elements from a list is easy too; you can simply use the del statement:
>>> names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
>>> del names[2]
>>> names
['Alice', 'Beth', 'Dee-Dee', 'Earl']


*.The 'del' statement may be used to delete things other than list elements. It can be used with dictionaries or even variables


*.Assigning to Slices:
Slicing is a very powerful feature, and it is made even more powerful by the fact that you can
assign to slices:
>>> name = list('Perl')
>>> name
['P', 'e', 'r', 'l']
>>> name[2:] = list('ar')
>>> name
['P', 'e', 'a', 'r']


*. when you use slice assignments, you
may also replace the slice with a sequence whose length is different from that of the original:
>>> name = list('Perl')
>>> name[1:] = list('ython')
>>> name
['P', 'y', 't', 'h', 'o', 'n']


*.Slice assignments can even be used to insert elements without replacing any of the
original ones:
>>> numbers = [1, 5]
>>> numbers[1:1] = [2, 3, 4]
>>> numbers
[1, 2, 3, 4, 5]


*.Here, I basically “replaced” an empty slice, thereby really inserting a sequence. You can do
the reverse to delete a slice:
>>> numbers
[1, 2, 3, 4, 5]
>>> numbers[1:4] = []
>>> numbers
[1, 5]


*.List Methods

A method is a function that is tightly coupled to some object, be it a list, a number, a string,
or whatever. In general, a method is called like this:

object.method(arguments)

As you can see, a method call looks just like a function call, except that the object is put
before the method name, with a dot separating them. Lists have several methods that allow
you to examine or modify their contents


*.append:
The append method is used to append an object to the end of a list:
>>> lst = [1, 2, 3]
>>> lst.append(4)
>>> lst
[1, 2, 3, 4]


It’s also important to note that append, like several similar methods, changes the list in
place. This means that it does not simply return a new, modified list—it modifies the old one
directly. This is usually what you want, but it may sometimes cause trouble. 


*.count:
The count method counts the occurrences of an element in a list:
>>> ['to', 'be', 'or', 'not', 'to', 'be'].count('to')
2
>>> x = [[1, 2], 1, 1, [2, 1, [1, 2]]]
>>> x.count(1)
2
>>> x.count([1, 2])
1


*.extend
The extend method allows you to append several values at once by supplying a sequence of the
values you want to append. In other words, your original list has been extended by the other one:
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a.extend(b)
>>> a
[1, 2, 3, 4, 5, 6]
This may seem similar to concatenation, but the important difference is that the extended
sequence (in this case, a) is modified. This is not the case in ordinary concatenation, in which
a completely new sequence is returned:
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a + b
[1, 2, 3, 4, 5, 6]
>>> a
[1, 2, 3]
As you can see, the concatenated list looks exactly the same as the extended one in the
previous example, yet a hasn’t changed this time. Because ordinary concatenation has to make
a new list that contains copies of a and b, it isn’t quite as efficient as using extend if what you
want is something like this:
>>> a = a + b
Also, this isn’t an in-place operation—it won’t modify the original.
The effect of extend can be achieved by assigning to slices, as follows:
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a[len(a):] = b
>>> a
[1, 2, 3, 4, 5, 6]
While this works, it isn’t quite as readable.


*.index
The index method is used for searching lists to find the index of the first occurrence of a value:
>>> knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
>>> knights.index('who')
4


*.insert
The insert method is used to insert an object into a list:
>>> numbers = [1, 2, 3, 5, 6, 7]
>>> numbers.insert(3, 'four')
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]
As with extend, you can implement insert with slice assignments:
>>> numbers = [1, 2, 3, 5, 6, 7]
>>> numbers[3:3] = ['four']
>>> numbers
[1, 2, 3, 'four', 5, 6, 7]


*.pop
The pop method removes an element (by default the last one) from the list and returns it:
>>> x = [1, 2, 3]
>>> x.pop()
3
>>> x
[1, 2]
>>> x.pop(0)
1
>>> x
[2]


*.The pop method is the only list method that both modifies the list and returns a value (other
than None).

*.Using pop, you can implement a common data structure called a stack. A stack like this
works just like a stack of plates. You can put plates on top, and you can remove plates from the
top. The last one you put into the stack is the first one to be removed. (This principle is called
Last-In, First-Out, or LIFO.)


*.The generally accepted names for the two stack operations (putting things in and taking
them out) are push and pop. Python doesn’t have push, but you can use append instead. The pop
and append methods reverse each other’s results, so if you push (or append) the value you just
popped, you end up with the same stack:
>>> x = [1, 2, 3]
>>> x.append(x.pop())
>>> x
[1, 2, 3]


*.remove
The remove method is used to remove the first occurrence of a value:
>>> x = ['to', 'be', 'or', 'not', 'to', 'be']
>>> x.remove('be')
>>> x

*.reverse
The reverse method reverses the elements in the list. (Not very surprising, I guess.)
>>> x = [1, 2, 3]
>>> x.reverse()
>>> x
[3, 2, 1]
Note that reverse changes the list and does not return anything (just like remove and sort,
for example)



*.sort
The sort method is used to sort lists in place.3 Sorting “in place” means changing the original
list so its elements are in sorted order, rather than simply returning a sorted copy of the list:
>>> x = [4, 6, 2, 1, 7, 9]
>>> x.sort()
>>> x
[1, 2, 4, 6, 7, 9]


*.You’ve encountered several methods already that modify the list without returning anything,
and in most cases that behavior is quite natural (as with append, for example). But I want to
emphasize this behavior in the case of sort because so many people seem to be confused by it.
The confusion usually occurs when users want a sorted copy of a list while leaving the original
alone. An intuitive (but wrong) way of doing this is as follows:
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x.sort() # Don't do this!
>>> print y
None
Because sort modifies x but returns nothing, you end up with a sorted x and a y containing
None. One correct way of doing this would be to first bind y to a copy of x, and then sort y,
as follows:
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x[:]
>>> y.sort()
>>> x
[4, 6, 2, 1, 7, 9]
>>> y
[1, 2, 4, 6, 7, 9]
Recall that x[:] is a slice containing all the elements of x, effectively a copy of the entire
list. Simply assigning x to y wouldn’t work because both x and y would refer to the same list:

>>> y = x
>>> y.sort()
>>> x
[1, 2, 4, 6, 7, 9]
>>> y
[1, 2, 4, 6, 7, 9]
Another way of getting a sorted copy of a list is using the sorted function:
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = sorted(x)
>>> x
[4, 6, 2, 1, 7, 9]
>>> y
[1, 2, 4, 6, 7, 9]
This function can actually be used on any sequence, but will always return a list:4
>>> sorted('Python')
['P', 'h', 'n', 'o', 't', 'y']
If you want to sort the elements in reverse order, you can use sort (or sorted), followed by
a call to the reverse method, or you could use the reverse argument, described in the following
section.


*.Advanced Sorting
If you want to have your elements sorted in a specific manner (other than sort’s default
behavior, which is to sort elements in ascending order) you can define your own comparison
function, of the form compare(x,y), which returns a negative number when x < y, a positive
number when x > y, and zero when x == y (according to your definition). You can then supply
this as a parameter to sort. The built-in function cmp provides the default behavior:
>>> cmp(42, 32)
1
>>> cmp(99, 100)
-1
>>> cmp(10, 10)
0
>>> numbers = [5, 2, 9, 7]
>>> numbers.sort(cmp)
>>> numbers
[2, 5, 7, 9]



The sort method has two other optional arguments as well—key and reverse. If you want
to use them, you normally specify them by name (so-called keyword arguments; you learn
more about those in Chapter 6). The key argument is similar to the cmp argument: You supply a function and it’s used in the sorting process. However, instead of being used directly for
determining whether one element is smaller than another, the function is used to create a key
for each element, and the elements are sorted according to these keys. So, for example, if you
want to sort the elements according to their lengths, you use len as the key function:
>>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate']
>>> x.sort(key=len)
>>> x
['add', 'acme', 'aerate', 'abalone', 'aardvark']

*.The other keyword argument, reverse, is simply a truth value (True or False; you learn
more about these in Chapter 5) indicating whether the list should be sorted in reverse:
>>> x = [4, 6, 2, 1, 7, 9]
>>> x.sort(reverse=True)
>>> x
[9, 7, 6, 4, 2, 1]
The cmp, key, and reverse arguments are available in the sorted function as well. In many
cases, using custom functions for cmp or key will be useful—you learn how to define your own
functions in Chapter 6.



*.TUPLES:IMMUTABLE SEQUENCES
 
Tuples are sequences, just like lists. The only difference is that tuples can’t be changed.5 (As you
may have noticed, this is also true of strings.) The tuple syntax is simple—if you separate some
values with commas, you automatically have a tuple:
>>> 1, 2, 3
(1, 2, 3)
As you can see, tuples may also be (and often are) enclosed in parentheses:
>>> (1, 2, 3)
(1, 2, 3)
The empty tuple is written as two parentheses containing nothing:
>>> ()
()



*.So, you may wonder how to write a tuple containing a single value. This is a bit peculiar—
you have to include a comma, even though there is only one value:
>>> 42
42
>>> 42,
(42,)
>>> (42,)
(42,)


*.The last two examples produce tuples of length one, while the first is not a tuple at all. The
comma is crucial. Simply adding parentheses won’t help: (42) is exactly the same as 42. One
lonely comma, however, can change the value of an expression completely:
>>> 3*(40+2)
126
>>> 3*(40+2,)
(42, 42, 42)


*.The tuple Function
The tuple function works in pretty much the same way as list: It takes one sequence argument
and converts it to a tuple.6 If the argument is already a tuple, it is returned unchanged:
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> tuple('abc')
('a', 'b', 'c')
>>> tuple((1, 2, 3))
(1, 2, 3)


*.Basic Tuple Operations
As you may have gathered, tuples aren’t very complicated—and there isn’t really much you can
do with them except make them and access their elements, and you do this the same as with
other sequences:
>>> x = 1, 2, 3
>>> x[1]
2
>>> x[0:2]
(1, 2)



*.A Quick Summary:

Let’s review some of the most important concepts covered in this chapter:

*Sequences: A sequence is a data structure in which the elements are numbered (starting
with zero). Examples of sequence types are lists, strings, and tuples. Of these, lists are
mutable (you can change them), whereas tuples and strings are immutable (once they’re
created, they’re fixed). Parts of a sequence can be accessed through slicing, supplying two
indices, indicating the starting and ending position of the slice. To change a list, you assign
new values to its positions, or use assignment to overwrite entire slices.

*.Membership: Whether a value can be found in a sequence (or other container) is checked
with the operator in. Using in with strings is a special case—it will let you look for substrings.

*.Methods: Some of the built-in types (such as lists and strings, but not tuples) have many
useful methods attached to them. These are a bit like functions, except that they are tied
closely to a specific value. Methods are an important aspect of object-oriented programming, which we look at later, in Chapter 7.



*.List of Functions learnt till now:
cmp(x, y) Compares two values
len(seq) Returns the length of a sequence
list(seq) Converts a sequence to a list
max(args) Returns the maximum of a sequence or set of arguments
min(args) Returns the minimum of a sequence or set of arguments
reversed(seq) Lets you iterate over a sequence in reverse
sorted(seq) Returns a sorted list of the elements of seq
tuple(seq) Converts a sequence to a tuple


*.BASIC STRING OPERATORATIONS:
*.All the standard sequence operations (indexing, slicing, multiplication, membership, length,
minimum, and maximum) work with strings.Remember,
however, that strings are immutable, so all kinds of item or slice assignments are illegal.

>>> website = 'http://www.python.org'
>>> website[-3:] = 'com'
Traceback (most recent call last):
File "<pyshell#19>", line 1, in ?
website[-3:] = 'com'
TypeError: object doesn't support slice assignment

*.String formatting is done with the string formatting operator, the percent (%) sign.

To the left of it you place a string (the format string), and to the right of it you place the
value you want to format. You can either use a single value such as a string or a number, or you
can use a tuple of values (if you want to format more than one), or, as I discuss in the next chapter,
you can use a dictionary. The most common case is the tuple:

>>> format = "Hello, %s. %s enough for ya?"
>>> values = ('world', 'Hot')
>>> print format % values
Hello, world. Hot enough for ya?


 If you use a list or some other sequence instead of a tuple, the sequence will be interpreted as
a single value. Only tuples and dictionaries (discussed in Chapter 4) will allow you to format more than
one value


The %s parts of the format string are called conversion specifiers. They mark the places
where the values are to be inserted. The s means that the values should be formatted as if they
were strings—if they aren’t, they’ll be converted with str.


To actually include a percent sign in the format string, you must write %% so Python doesn’t mistake
it for the beginning of a conversion specifier.


If you are formatting real numbers (floats), you can use the f specifier type and supply the
precision as a . (dot) followed by the number of decimals you want to keep. The format specifier
always ends with a type character, so you must put the precision before that:
>>> format = "Pi with three decimals: %.3f"
>>> from math import pi
>>> print format % pi
Pi with three decimals: 3.142


TEMPLATE STRINGS:
-----------------
The string module offers another way of formatting values: template strings. They work more like variable
substitution in many UNIX shells, with $foo being replaced by a keyword argument called foo that is passed
to the template method substitute:1

it is like substituting  a string in a predefined  string template.


>>> from string import Template
>>> s = Template("$x,welcome to freshers party $x!!")
>>> s.substitute(x = "kiran")
'kiran,welcome to freshers party kiran!!'

Consider the above situation where we are using the template 's' to welcome freshers to freshers party.
So just by passing different names to the template we can welcome everyone to the party without writting the sentence everytime.


If the replacement field is part of a word, the name must be enclosed in braces, in order to make it clear where
it ends:
>>> s = Template("It's ${x}tastic!")
>>> s.substitute(x='slurm')
"It's slurmtastic!

In order to insert a dollar sign, use $$:
>>> s = Template("Make $$ selling $x!")
>>> s.substitute(x='slurm')
'Make $ selling slurm!'

Instead of using keyword arguments, you can supply the value-name pairs in a dictionary (see Chapter 4):
>>> s = Template('A $thing must never $action.')
>>> d = {}
>>> d['thing'] = 'gentleman'
>>> d['action'] = 'show his socks'
>>> s.substitute(d)
'A gentleman must never show his socks.

There is also a method called safe_substitute that will not complain about missing values or incorrect uses of the $ character(Python Library Reference (http://
python.org/doc/lib/node108.html))

*.If you write the tuple to be converted as part of the conversion expression, you must enclose it in parentheses to avoid confusing Python:

>>> '%s plus %s equals %s' % (1, 1, 2)
'1 plus 1 equals 2'
>>> '%s plus %s equals %s' % 1, 1, 2 # Lacks parentheses!
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: not enough arguments for format string



CONVERSION SPECIFIER ANATOMY
A basic conversion specifier (as opposed to a full conversion specifier, which may contain a mapping key as
well; see Chapter 4 for more information) consists of the items that follow. Note here that the order is crucial.
• The % character. This marks the beginning of the conversion specifier.
• Conversion flags (optional). These may be either -, indicating left alignment; +, indicating that a sign
should precede the converted value; “ ” (a space character), indicating that a space should precede
positive numbers; or 0, indicating that the conversion should be zero-padded.
• The minimum field width (optional). The converted string will be at least this wide. If this is an *
(asterisk), the width will be read from the value tuple.
• A . (dot) followed by the precision (optional). If a real number is converted, this many decimals should
be shown. If a string is converted, this number is that maximum field width. If this is an * (asterisk), the
precision will be read from the value tuple.
• The conversion type (see Table 3-1)


Simple Conversion:
The simple conversion, with only a conversion type, is really easy to use:
>>> 'Price of eggs: $%d' % 42
'Price of eggs: $42'
>>> 'Hexadecimal price of eggs: %x' % 42
'Hexadecimal price of eggs: 2a'
>>> from math import pi
>>> 'Pi: %f...' % pi
'Pi: 3.141593...'
>>> 'Very inexact estimate of pi: %i' % pi
'Very inexact estimate of pi: 3'
>>> 'Using str: %s' % 42L
'Using str: 42'
>>> 'Using repr: %r' % 42L
'Using repr: 42L'


*****String Formatting Conversion Types******

Conversion  Type Meaning
d, i 	Signed integer decimal
o 	Unsigned octal
u 	Unsigned decimal
x 	Unsigned hexadecimal (lowercase)
X 	Unsigned hexadecimal (uppercase)
e 	Floating point exponential format (lowercase)
E 	Floating point exponential format (uppercase)
f, F 	Floating point decimal format
g 	Same as e if exponent is greater than –4 or less than precision, f otherwise
G 	Same as E if exponent is greater than –4 or less than precision, F otherwise
c 	Single character (accepts integer or single character string)
r 	String (converts any Python object using repr)


*. WIDTH & PRECISION
A conversion specifier may include a field width and a precision. The width is the minimum
number of characters reserved for a formatted value, while the precision is (for a numeric
conversion) the number of decimals that will be included in the result, or (for a string conversion)
the maximum number of characters the formatted value may have.
These two parameters are supplied as two integer numbers (width first, then precision),
separated by a . (dot). Both are optional, but if you want to supply only the precision, you must
also include the dot:
>>> '%10f' % pi # Field width 10
' 3.141593'
>>> '%10.2f' % pi # Field width 10, precision 2
' 3.14'
>>> '%.2f' % pi # Precision 2
'3.14'
>>> '%.5s' % 'Guido van Rossum'
'Guido'
You can use an * (asterisk) as the width or precision (or both), in which case the number
will be read from the tuple argument:
>>> '%.*s' % (5, 'Guido van Rossum')
'Guido



Signs, Alignment, and Zero-Padding
Before the width and precision numbers, you may put a “flag,” which may be either zero, plus,
minus, or blank. A zero means that the number will be zero-padded:
>>> '%010.2f' % pi
'0000003.14'
It’s important to note here that the leading zero in 010 in the preceding code does not
mean that the width specifier is an octal number, as it would in a normal Python number.
When you use 010 as the width specifier, it means that the width should be 10 and that the
number should be zero-padded, not that the width should be 8:
>>> 010
8
A minus sign (-) left-aligns the value:
>>> '%-10.2f' % pi
'3.14 '
As you can see, any extra space is put on the right-hand side of the number.
A blank (“ ”) means that a blank should be put in front of positive numbers. This may be
useful for aligning positive and negative numbers:
>>> print ('% 5d' % 10) + '\n' + ('% 5d' % -10)
10
-10
Finally, a plus (+) means that a sign (either plus or minus) should precede both positive
and negative numbers (again, useful for aligning):
>>> print ('%+5d' % 10) + '\n' + ('%+5d' % -10)
+10
-10
In the following example, I use the asterisk width specifier to format a table of fruit prices,
where the user enters the total width of the table. Because this information is supplied by the
user, I can’t hard-code the field widths in my conversion specifiers; by using the asterisk, I can
have the field width read from the converted tuple. The source code is given in Listing 3-1



isting 3-1. String Formatting Example
# Print a formatted price list with a given width
width = input('Please enter width: ')
price_width = 10
item_width = width - price_width
header_format = '%-*s%*s'
format = '%-*s%*.2f'
print '=' * width
print header_format % (item_width, 'Item', price_width, 'Price')
print '-' * width
print format % (item_width, 'Apples', price_width, 0.4)
print format % (item_width, 'Pears', price_width, 0.5)
print format % (item_width, 'Cantaloupes', price_width, 1.92)
print format % (item_width, 'Dried Apricots (16 oz.)', price_width, 8)
print format % (item_width, 'Prunes (4 lbs.)', price_width, 12)
print '=' * width
The following is a sample run of the program:

Please enter width: 35
===================================
Item 			Price
———————————————————————————————————
Apples 			0.40
Pears 			0.50
Cantaloupes 		1.92
Dried Apricots (16 oz.) 8.00
Prunes (4 lbs.) 	12.00
===================================



String Methods:

You have already encountered methods in lists. Strings have a much richer set of methods, in
part because strings have “inherited” many of their methods from the string module where
they resided as functions in earlier versions of Python (and where you may still find them, if
you feel the need)

*******************OPTIONAL**********************
--------------------------------------------------
Even though string methods have completely upstaged the string module, the module still includes a few
constants and functions that aren’t available as string methods. The maketrans function is one example and
will be discussed together with the translate method in the material that follows. Table 3-2 shows some
useful constants available from string. For a more thorough description of the module, check out Section 4.1
of the Python Library Reference (http://python.org/doc/lib/module-string.html).

-------------------------------------------------
*******************END***************************


*.find
The find method finds a substring within a larger string. It returns the leftmost index where the
substring is found. If it is not found, –1 is returned:
>>> 'With a moo-moo here, and a moo-moo there'.find('moo')
7
>>> title = "Monty Python's Flying Circus"
>>> title.find('Monty')
0
>>> title.find('Python')
6
>>> title.find('Flying')
15
>>> title.find('Zirquss')
-1


The string method find does not return a Boolean value. If find returns 0, as it did here, it means
that it has found the substring, at index zero


You may also supply a starting point for your search and, optionally, also an ending point:
>>> subject = '$$$ Get rich now!!! $$$'
>>> subject.find('$$$')
0
>>> subject.find('$$$', 1) # Only supplying the start
20
>>> subject.find('!!!')
16
>>> subject.find('!!!', 0, 16) # Supplying start and end
-1

here starting point is inclusive and ending point is exclusive


*.join
A very important string method, join is the inverse of split, and is used to join the elements of
a sequence:
>>> seq = [1, 2, 3, 4, 5]
>>> sep = '+'
>>> sep.join(seq) # Trying to join a list of numbers
Traceback (most recent call last):
File "<stdin>", line 1, in ?
TypeError: sequence item 0: expected string, int found
>>> seq = ['1', '2', '3', '4', '5']
>>> sep.join(seq) # Joining a list of strings
'1+2+3+4+5'
>>> dirs = '', 'usr', 'bin', 'env'
>>> '/'.join(dirs)
'/usr/bin/env'
>>> print 'C:' + '\\'.join(dirs)
C:\usr\bin\env


*.split
>>> "Hello".split('l') #split hello at l
['He','','o']

*.lower
The lower method returns a lowercase version of the string:
>>> 'Trondheim Hammer Dance'.lower()
'trondheim hammer dance'

*.translate()
The method translate() returns a copy of the string in which all characters have been translated using table (constructed with the maketrans() function in the string module), optionally deleting all characters found in the string deletechars.

syntax:str.translate(table[, deletechars]);

>>> a = "jfnailufoipkm pkbrmniuvhe897uhuiojb;90iusre"

#to remove all j's anf f's from a, None is for table in translate's syntax

>>> a.translate(None,'jf')
'nailuoipkm pkbrmniuvhe897uhuiob;90iusre'

*.SOME OTHER METHODS: islower, capitalize, swapcase, title, istitle, upper, isupper


*.replace
The replace method returns a string where all the occurrences of one string have been replaced
by another:
>>> 'This is a test'.replace('is', 'eez')
'Theez eez a test'



*.split
A very important string method, split is the inverse of join, and is used to split a string into
a sequence:
>>> '1+2+3+4+5'.split('+')
['1', '2', '3', '4', '5']
>>> '/usr/bin/env'.split('/')
['', 'usr', 'bin', 'env']
>>> 'Using the default'.split()
['Using', 'the', 'default']
Note that if no separator is supplied, the default is to split on all runs of consecutive
whitespace characters (spaces, tabs, newlines, and so on).
See also: join.
In Appendix B: rsplit, splitlines.


*.strip
The strip method returns a string where whitespace on the left and right (but not internally)
has been stripped (removed):
>>> ' internal whitespace is kept '.strip()
'internal whitespace is kept'

*.As with lower, strip can be useful when comparing input to stored values. Let’s return to
the user name example from the section on lower, and let’s say that the user inadvertently
types a space after his name:
>>> names = ['gumby', 'smith', 'jones']
>>> name = 'gumby '
>>> if name in names: print 'Found it!'
...
>>> if name.strip() in names: print 'Found it!'
...
Found it!
>>>



*.You can also specify which characters are to be stripped, by listing them all in a string
parameter:
>>> '*** SPAM * for * everyone!!! ***'.strip(' *!')
'SPAM * for * everyone'


*.translate
Similar to replace, translate replaces parts of a string, but unlike replace, translate only works
with single characters. Its strength lies in that it can perform several replacements simultaneously,
and can do so more efficiently than replace.
There are quite a few rather technical uses for this method (such as translating newline
characters or other platform-dependent special characters), but let’s consider a simpler
(although slightly more silly) example. Let’s say you want to translate a plain English text into
one with a German accent. To do this, you must replace the character “c” with “k,” and “s” with “z.”
Before you can use translate, however, you must make a translation table. This translation
table is a full listing of which characters should be replaced by which. Because this table (which is
actually just a string) has 256 entries, you won’t write it out yourself: You’ll use the function
maketrans from the string module.
The maketrans function takes two arguments: two strings of equal length, indicating that
each character in the first string should be replaced by the character in the same position in the
second string. Got that? In the case of our simple example, the code would look like the following:
>>> from string import maketrans
>>> table = maketrans('cs', 'kz')



*.WHAT’S IN A TRANSLATION TABLE?
A translation table is a string containing one replacement letter for each of the 256 characters in the ASCII
character set:
>>> table = maketrans('cs', 'kz')
>>> len(table)
256
>>> table[97:123]
'abkdefghijklmnopqrztuvwxyz'
>>> maketrans('', '')[97:123]
'abcdefghijklmnopqrstuvwxyz'
As you can see, I’ve sliced out the part of the table that corresponds to the lowercase letters. Take a look
at the alphabet in the table and that in the empty translation (which doesn’t change anything). The empty
translation has a normal alphabet, while in the preceding code, the letter “c” has been replaced by “k,” and
“s” has been replaced by “z.”
Once you have this table, you can use it as an argument to the translate method, thereby
translating your string:
>>> 'this is an incredible test'.translate(table)
'thiz iz an inkredible tezt


An optional second argument can be supplied to translate, specifying letters that should
be deleted. If you wanted to emulate a really fast-talking German, for instance, you could
delete all the spaces:
>>> 'this is an incredible test'.translate(table, ' ')
'thizizaninkredibletezt'


*.Tip Sometimes string methods such as lower won’t work quite the way you want them to—for instance,
if you happen to use a non-English alphabet. Let’s say you want to convert the uppercase Norwegian word
“BØLLEFRØ” to its lowercase equivalent:
>>> print 'BØLLEFRØ'.lower()
bØllefrØ
As you can see, this didn’t really work because Python doesn’t consider “Ø” a real letter. In this case, you can
use translate to do the translation:
>>> table = maketrans('ÆØÅ', 'æøå')
>>> word = 'KÅPESØM'
>>> print word.lower()
kÅpesØm
>>> print word.translate(table)
KåPESøM
>>> print word.translate(table).lower()
kåpesøm

*.String formatting. The modulo operator (%) can be used to splice values into a string that
contains conversion flags, such as %s. You can use this to format values in many ways,
including right or left justification, setting a specific field width and precision, adding a
sign (plus or minus), or left-padding with zeros.

*.New function recently learnt 
Function 			Description
string.maketrans(from, to) 	Makes a translation table 					for translate





--------------------------------------------------------------

DICTIONARIES: When Indices Won't Work :)

*.Dictionaries are a type of data structures where instead of indices we use vale:key pairs to access any element of that data structure.This type of data structure is called mapping.

*.The lesson is this: Telephone numbers (and other numbers that may contain leading zeros) should be represented as strings of digits—not integers.
Because when any number starts from 0 it is considered as a octal value 

>>> 045
37

& numbers like 9 and 8 are not possible at all
>>> 089
  File "<stdin>", line 1
    089

*.Dictionary Syntax
Dictionaries are written like this:
phonebook = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}


*.Dictionaries consist of pairs (called items) of keys and their corresponding values. In the
preceding example, the names are the keys and the telephone numbers are the values. Each
key is separated from its value by a colon (:), the items are separated by commas, and the
whole thing is enclosed in curly braces. An empty dictionary (without any items) is written with
just two curly braces, like this: {}

*.Keys are unique within a dictionary (and any other kind of mapping), while values may not be.

*.The dict Function
You can use the dict function to construct dictionaries from other mappings (for example,
other dictionaries) or from sequences of (key, value) pairs:
>>> items = [('name', 'Gumby'), ('age', 42)]
>>> d = dict(items)
>>> d
{'age': 42, 'name': 'Gumby'}
>>> d['name']
'Gumby'
It can also be used with keyword arguments, as follows:
>>> d = dict(name='Gumby', age=42)
>>> d
{'age': 42, 'name': 'Gumby'}

Although this is probably the most useful application of dict, you can also use it with a
mapping argument to create a dictionary with the same items as the mapping. (If used without
any arguments, it returns a new empty dictionary, just like other similar functions such as list,
tuple, or str.) If the other mapping is a dictionary (which is, after all, the only built-in mapping
type), you can use the dictionary method copy instead, as described later.


The dict function isn’t really a function at all. It is a type, just like list, tuple, and str



*.Basic Dictionary Operations
The basic behavior of a dictionary in many ways mirrors that of a sequence: len(d) returns the
number of items (key-value pairs) in d, d[k] returns the value associated with the key k, d[k] = v
associates the value v with the key k, del d[k] deletes the item with key k, and k in d checks
whether there is an item in d that has the key k. Although they share several common characteristics, there are some important distinctions:

• Dictionary keys don’t have to be integers (though they may be). They may be any immutable type, such as floating-point (real) numbers, strings, or tuples.

• You can assign a value to a key even if that key isn’t in the dictionary to begin with; a new
item will be created. You cannot assign a value to an index outside the list’s range
(without using append or something like that).

• The expression k in d (where d is a dictionary) looks for a key, not a value. The expression
v in l, on the other hand (where l is a list) looks for a value, not an index. This may seem
a bit inconsistent, but it is actually quite natural when you get used to it. After all, if the
dictionary has the given key, checking the corresponding value is easy.

Checking for key membership in a dictionary is much more efficient than checking for membership in
a list—and the difference is greater the larger the data structures are


The first point—that the keys may be of any immutable type—is the main strength of
dictionaries, while the second point is important, too. Just look at the difference here:
>>> x = []
>>> x[42] = 'Foobar'
Traceback (most recent call last):
File "<stdin>", line 1, in ?
IndexError: list assignment index out of range
>>> x = {}
>>> x[42] = 'Foobar'
>>> x
{42: 'Foobar'}
First, I try to assign the string 'Foobar' to position 42 in an empty list—clearly impossible
because that position does not exist. To make this possible, I would have to initialize x with
[None]*43 or something, rather than simply []. The next attempt, however, works perfectly.
Here I assign 'Foobar' to the key 42 of an empty dictionary; no problem! A new item is simply
added to the dictionary and I’m in business.

*.Example: 
Listing 4-1 shows the code for the telephone book example. Here is a sample run of the program:
Name: Beth
Phone number (p) or address (a)? p
Beth's phone number is 9102.
Listing 4-1. Dictionary Example
# A simple database
# A dictionary with person names as keys. Each person is represented as
# another dictionary with the keys 'phone' and 'addr' referring to their phone
# number and address, respectively




people = {
'Alice': {
'phone': '2341',
'addr': 'Foo drive 23'
},
'Beth': {
'phone': '9102',
'addr': 'Bar street 42'
},
'Cecil': {
'phone': '3158',
'addr': 'Baz avenue 90'
}
}
# Descriptive labels for the phone number and address. These will be used
# when printing the output.
labels = {
'phone': 'phone number',
'addr': 'address'
}
name = raw_input('Name: ')
# Are we looking for a phone number or an address?
request = raw_input('Phone number (p) or address (a)? ')
# Use the correct key:
if request == 'p': key = 'phone'
if request == 'a': key = 'addr'
# Only try to print information if the name is a valid key in our dictionary:
if name in people: print "%s's %s is %s." % (name, labels[key], people[name][key])


String Formatting with Dictionaries
After the % character in each conversion specifier, you add a key
(enclosed in parentheses), which is followed by the other specifier elements:
>>> phonebook
{'Beth': '9102', 'Alice': '2341', 'Cecil': '3258'}
>>> "Cecil's phone number is %(Cecil)s." % phonebook
"Cecil's phone number is 3258."
Except for the added string key, the conversion specifiers work as before. When using
dictionaries like this, you may have any number of conversion specifiers, as long as all the
given keys are found in the dictionary. 


This sort of string formatting can be very useful in
template systems (in this case using HTML):
>>> template = '''<html>
<head><title>%(title)s</title></head>
<body>
<h1>%(title)s</h1>
<p>%(text)s</p>
</body>'''
>>> data = {'title': 'My Home Page', 'text': 'Welcome to my home page!'}
>>> print template % data
<html>
<head><title>My Home Page</title></head>
<body>
<h1>My Home Page</h1>
<p>Welcome to my home page!</p>


*.Dictionary Methods:

*.clear
The clear method removes all items from the dictionary. This is an in-place operation (like
list.sort), so it returns nothing (or, rather, None):
>>> d = {}
>>> d['name'] = 'Gumby'
>>> d['age'] = 42
>>> d
{'age': 42, 'name': 'Gumby'}
</body>
>>> returned_value = d.clear()
>>> d
{}

Why is this useful? Consider the following scenarios, and notice the difference in behavior.
Scenario 1:
>>> x = {}
>>> y = x
>>> x['key'] = 'value'
>>> y
{'key': 'value'}
>>> x = {}
>>> y
{'key': 'value'}
Scenario 2:
>>> x = {}
>>> y = x
>>> x['key'] = 'value'
>>> y
{'key': 'value'}
>>> x.clear()
>>> y
{}
In both scenarios, x and y originally refer to the same dictionary. In the first scenario, I
“blank out” x by assigning a new, empty dictionary to it. That doesn’t affect y at all, which still
refers to the original dictionary. This may be the behavior you want, but if you really want to
remove all the elements of the original dictionary, you must use clear. As you can see in the
second scenario, y is then also empty afterward.


copy
The copy method returns a new dictionary with the same key-value pairs (a shallow copy, since
the values themselves are the same, not copies):
>>> x = {'username': 'admin', 'machines': ['foo', 'bar', 'baz']}
>>> y = x.copy()
>>> y['username'] = 'mlh'
>>> y['machines'].remove('bar')
>>> y
{'username': 'mlh', 'machines': ['foo', 'baz']}
>>> x
{'username': 'admin', 'machines': ['foo', 'baz']}


As you can see, when you replace a value in the copy, the original is unaffected. However,
if you modify a value (in place, without replacing it), the original is changed as well because the
same value is stored there (like the “machines” list in this example


One way to avoid that problem is to make a deep copy, copying the values, any values they contain,
and so forth as well. You accomplish this using the function deepcopy from the copy module:
>>> from copy import deepcopy
>>> d = {}
>>> d['names'] = ['Alfred', 'Bertrand']
>>> c = d.copy()
>>> dc = deepcopy(d)
>>> d['names'].append('Clive')
>>> c
{'names': ['Alfred', 'Bertrand', 'Clive']}
>>> dc
{'names': ['Alfred', 'Bertrand']}


*.fromkeys
The fromkeys method creates a new dictionary with the given keys, each with a default corresponding value of None:
>>> {}.fromkeys(['name', 'age'])
{'age': None, 'name': None}
The previous example first constructs an empty dictionary and then calls the fromkeys
method on that, in order to create another dictionary—a somewhat redundant strategy. Instead,
you can call the method directly on dict, which (as mentioned before) is the type of all dictionaries. (The concept of types and classes is discussed more thoroughly in Chapter 7.)
>>> dict.fromkeys(['name', 'age'])
{'age': None, 'name': None}
If you don’t want to use None as the default value, you can supply your own default:
>>> dict.fromkeys(['name', 'age'], '(unknown)')
{'age': '(unknown)', 'name': '(unknown)'}


*.get
The get method is a forgiving way of accessing dictionary items. Ordinarily, when you try to
access an item that is not present in the dictionary, things go very wrong:

>>> d = {}
>>> print d['name']
Traceback (most recent call last):
File "<stdin>", line 1, in ?
KeyError: 'name'
Not so with get:
>>> print d.get('name')
None
As you can see, when you use get to access a nonexistent key, there is no exception. Instead,
you get the value None. You may supply your own “default” value, which is then used instead
of None:
>>> d.get('name', 'N/A')
'N/A'
If the key is there, get works like ordinary dictionary lookup:
>>> d['name'] = 'Eric'
>>> d.get('name')
'Eric

has_key
The has_key method checks whether a dictionary has a given key. The expression d.has_key(k)
is equivalent to k in d. The choice of which to use is largely a matter of taste.
Here is an example of how you might use has_key:
>>> d = {}
>>> d.has_key('name')
0
>>> d['name'] = 'Eric'
>>> d.has_key('name')
1


*.items and iteritems
The items method returns all the items of the dictionary as a list of items in which each item is
of the form (key, value). The items are not returned in any particular order:
>>> d = {'title': 'Python Web Site', 'url': 'http://www.python.org', 'spam': 0}
>>> d.items()
[('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
The iteritems method works in much the same way, but returns an iterator instead of a list

>>> it = d.iteritems()
>>> it
<dictionary-iterator object at 169050>
>>> list(it) # Convert the iterator to a list
[('url', 'http://www.python.org'), ('spam', 0), ('title', 'Python Web Site')]
Using iteritems may be more efficient in many cases (especially if you want to iterate over
the result). For more information on iterators, see Chapter 9.

*.keys and iterkeys
The keys method returns a list of the keys in the dictionary, while iterkeys returns an iterator
over the keys.

*.pop
The pop method can be used to get the value corresponding to a given key, and then remove the
key-value pair from the dictionary:
>>> d = {'x': 1, 'y': 2}
>>> d.pop('x')
1
>>> d
{'y': 2}


*.popitem
The popitem method is similar to list.pop. Unlike list.pop, however, popitem pops off a random
item because dictionaries don’t have a “last element” or any order whatsoever. This may be
very useful if you want to remove and process the items one by one in an efficient way (without
retrieving a list of the keys first):
>>> d
{'url': 'http://www.python.org', 'spam': 0, 'title': 'Python Web Site'}
>>> d.popitem()
('url', 'http://www.python.org')
>>> d
{'spam': 0, 'title': 'Python Web Site'}
Although popitem is similar to the list method pop, there is no dictionary equivalent of
append. Because dictionaries have no order, such a method wouldn’t make any sense.


*.setdefault
The setdefault method is somewhat similar to get, except that in addition to the get functionality, setdefault sets the value corresponding to the given key if it is not already in the dictionary:

>> d = {}
>>> d.setdefault('name', 'N/A')
'N/A'
>>> d
{'name': 'N/A'}
>>> d['name'] = 'Gumby'
>>> d.setdefault('name', 'N/A')
'Gumby'
>>> d
{'name': 'Gumby'}
As you can see, when the key is missing, setdefault returns the default and updates the
dictionary accordingly. If the key is present, its value is returned and the dictionary is left
unchanged. The default is optional, as with get; if it is left out, None is used:
>>> d = {}
>>> print d.setdefault('name')
None
>>> d
{'name': None}


*.update
The update method updates one dictionary with the items of another:
>>> d = {
'title': 'Python Web Site',
'url': 'http://www.python.org',
'changed': 'Mar 14 22:09:15 MET 2005'
}
>>> x = {'title': 'Python Language Website'}
>>> d.update(x)
>>> d
{'url': 'http://www.python.org', 'changed': 'Mar 14 22:09:15 MET 2005',
'title': 'Python Language Website'}
The items in the supplied dictionary are added to the old one, overwriting any items there
with the same keys.
The update method can be called in the same way as the dict function (or type constructor),
as discussed earlier in this chapter. This means that update can be called with a mapping, a
sequence (or other iterable object) of (key, value) pairs, or with keyword arguments.


*.values and itervalues
The values method returns a list of the values in the dictionary (and itervalues returns an iterator
of the values). Unlike keys, the list returned by values may contain duplicates:

>>> d = {}
>>> d[1] = 1
>>> d[2] = 2
>>> d[3] = 3
>>> d[4] = 1
>>> d.values()
[1, 2, 3, 1]


A Quick Summary
In this chapter, you learned about the following:
Mappings. A mapping enables you to label its elements with any immutable object, the
most usual types being strings and tuples. The only built-in mapping type in Python is the
dictionary.
String formatting with dictionaries. You can apply the string formatting operation to
dictionaries by including names (keys) in the formatting specifiers. When using tuples in
string formatting, you need to have one formatting specifier for each element in the tuple.
When using dictionaries, you can have fewer specifiers than you have items in the dictionary.
Dictionary methods. Dictionaries have quite a few methods, which are called in the same
way as list and string methods.


------------------------------------------------------------------
CONDITIONAL LOOPS & SOME OTHER STATMENTS


MORE ABOUT PRINT & IMPORT:

*.Printing with Commas
You’ve seen how print can be used to print an expression, which is either a string or is automatically converted to one. But you can actually print more than one expression, as long as you
separate them with commas:
>>> print 'Age:', 42
Age: 42
As you can see, a space character is inserted between each argument.


*. The arguments of print do not form a tuple, as one might expect:
>>> 1, 2, 3
(1, 2, 3)
>>> print 1, 2, 3
1 2 3
>>> print (1, 2, 3)
(1, 2, 3)


*.This behavior can be very useful if you want to combine text and variable values without
using the full power of string formatting:
>>> name = 'Gumby'
>>> salutation = 'Mr.'
>>> greeting = 'Hello,'
>>> print greeting, salutation, name
Hello, Mr. Gumby




